/* lex.c - lexical analysis pass

   This file is part of Luanova, a fresh implementation of Lua.


   Copyright Â© 2022 Joris van der Geer.

   Luanova is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Luanova is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU Affero General Public License
   along with this program, typically in the file License.txt
   If not, see http://www.gnu.org/licenses.
 */

/* This is an FSM-based lexical analyzer, the FSM being generated by genlex from a specification.
   The input source file is read completely into a character array.
   Output is a list of tokens with attributes, values and file coords.
   Identifiers and string literals are interned in a hash table.
   String literals are concatenated.
   Numerical literals are decoded.

   A file coordinate is a single 32-bit integer providing a filename, include stack, line and column pos.
   This is facilitated with the help of a line table and file table.
 */

#include <stdarg.h>
#include <string.h>
#include <stdlib.h>

#include "base.h"
#include "chr.h"

// #include "os.h"

#include "mem.h"

#include "fmt.h"

static ub4 msgfile = Shsrc_lex;
#include "msg.h"

#include "map.h"

#undef ice
#define ice(fpos,fmt,...) icefln(FLN,0,fpos,fmt,__VA_ARGS__)

#include "util.h"

#include "pre.h"
#include "lexsyn.h"
#include "lex.h"
#include "lsa.h"

// todo   nlit interning, ctls/atrs/bits

// max brackets nesting and indents
#define Depth 256

#define Emitdetail

#if defined __clang__
 #pragma clang diagnostic ignored "-Wsign-conversion"
 #pragma clang diagnostic ignored "-Wduplicate-enum"
 #pragma clang diagnostic ignored "-Wgnu-label-as-value"

#elif defined __GNUC__
 #pragma GCC diagnostic ignored "-Wsign-conversion"
 #pragma GCC diagnostic ignored "-Wpointer-sign"
 #pragma GCC diagnostic ignored "-Wunused-variable"
 #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
#endif

#include "hash.h"

// generated by genlex
#include "tok.h"
#include "lexdef.h"

static bool verbose;

static bool lang_concat = 0;

static char cursrc[256];

#define Slitint 256

enum Packed8 Esc { Esc_inv,Esc_nl,Esc_o,Esc_x,Esc_u,Esc_U,Esc_N,Esc_a=7,Esc_b,Esc_t,Esc_n,Esc_v,Esc_f,Esc_r };

static const enum Esc esctab[128] = {
  ['\n'] = Esc_nl,
  ['\\'] = '\\',
  ['\''] = '\'',
  ['"'] = '"',
  ['0'] = Esc_o, ['1'] = Esc_o, ['2'] = Esc_o, ['3'] = Esc_o, ['4'] = Esc_o, ['5'] = Esc_o, ['6'] = Esc_o, ['7'] = Esc_o,
  ['f'] = Esc_f,
  ['t'] = Esc_t,
  ['n'] = Esc_n,
  ['r'] = Esc_r,
  ['v'] = Esc_v,
  ['a'] = Esc_a,
  ['b'] = Esc_b,
  ['x'] = Esc_x,
  ['u'] = Esc_u, ['U'] = Esc_U,
  ['N'] = Esc_N
};

static ub1 pass;
static cchar *srcnam;

static ub4 strlen4(cchar *s) { return (ub4)strlen(s); }

static inline ub4 align4(ub4 x)
{
  return x & 3 ? (x & ~3) + 1 : x;
}

static cchar *tknam(enum Token tk)
{
  ub2 len;
  ub1 hc;
  static char basbuf[4 * 16];
  char *buf;
  static ub2 bufno;

  buf = basbuf + bufno * 16;
  bufno = (bufno + 1) & 3;

  char *p,*q;

  if (tk >= T99_count) return "*inv*";
#if Kwcnt > 0
  else if (tk < T99_kwd) { memcpy(buf,kwnampool + kwnamposs[tk],len=kwnamlens[tk]); buf[len] = 0; }
#endif
  else {
    tk -= T99_kwd;
    hc = tokhrctl[tk] & 0xf;
    if (hc == 0) return toknampool + toknampos[tk];
    p = hrtoknams + tk * 4;
    q = buf;
    while (hc--) *q++ = *p++;
    *q = 0;
  }
  return buf;
}

static cchar *bltnam(enum Bltin blt,ub4 *plen)
{
  ub2 len=0;
  static char basbuf[4 * 16];
  char *buf;
  static ub2 bufno;

  buf = basbuf + bufno * 16;
  bufno = (bufno + 1) & 3;

  blt = min(blt,B99_count);
#ifdef Bltcnt
  memcpy(buf,bltnampool + bltnamposs[blt],len=bltnamlens[blt]);
#endif
 buf[len] = 0;
 if (plen) *plen = len;
 return buf;
}

static cchar *dunnam(enum Dunder dun)
{
  ub2 len=0;
  static char basbuf[4 * 16];
  char *buf;
  static ub2 bufno;

  buf = basbuf + bufno * 16;
  bufno = (bufno + 1) & 3;

  dun = min(dun,D99_count);
#ifdef Duncnt
  memcpy(buf,dun0nampool + dunnamposs[dun],len=dunnamlens[dun]);
#endif
 buf[len] = 0;
 return buf;
}

static void lxdiag(enum Msglvl lvl,ub4 ln,ub4 col,cchar *state,cchar *pat,ub4 c,cchar *msg)
{
  char buf[1024];
  ub4 pos=0,blen = 1024;

  if (verbose) pos = mysnprintf(buf,0,blen,"%s state %s pattern '%s'",specnam,state,pat);

  if (c != hi16) pos += mysnprintf(buf,pos,blen,"at char '%s' : ",chprint(c));
  buf[pos] = 0;

  if (msg == nil) msg = "unexpected";
  vpmsg(FLN,lvl,srcnam,ln+1,col+1,buf,nil,msg);
}

static Noret void lxerror(ub4 ln,ub4 col,cchar *state,cchar *pat,ub4 c,cchar *msg)
{
  lxdiag(Fatal,ln,col,state,pat,c,msg);
  doexit(1);
}

static void lxwarn(ub4 ln,ub4 col,cchar *state,cchar *pat,ub4 c,cchar *msg)
{
  lxdiag(Warn,ln,col,state,pat,c,msg);
}

static void lxinfo(ub4 ln,ub4 col,cchar *msg)
{
  vpmsg(FLN,Info,srcnam,ln+1,col+1,msg,nil,nil);
}

// todo static to local

// string lits
static ub4 slit0cnt,slitlimcnt;
static ub4 slitpos,slittop;
static ub4 slitucnt,slitidlen;

static ub4 *slithsh;
static ub4 slithshlen,slithshmask,slithshcnt,slithshmis;
static ub1 slithshbit;

static ub8 *slitids;

static ub4 slithilen, slithipos;

// idents
static ub4 uidcnt,uid1cnt,uid2cnt;

static struct map idtab;

static ub1 id2loch1,id2hich1,id2chlen;
static ub2 *id2tab;
static ub2 *id2nams;
static ub1 id2nch1,id2nch2,id2shift1,id2shift2;
static ub2 id2mask1,id2mask2;

static ub2 id2getadd(ub2 n,ub1 c1,ub1 c2)
{
  ub2 a = c1 - id2loch1;
  ub2 b = c2;
  ub2 id;
  ub2 ndx;

  ndx = (b * id2chlen) + a;
  id = id2tab[ndx];
  if (id != hi16) {
    return id;
  }
  id2tab[ndx] = uid2cnt;
  id2nams[uid2cnt] = ndx;
  return uid2cnt++;
}

static ub1 id1tab[256];
static ub1 id1inv[256];

static ub1 id1getadd(ub1 c)
{
  ub1 id = id1tab[c];

  if (id == 0xff) {
    id = uid1cnt++;
    id1tab[c] = id;
    id1inv[id] = c;
  }
  return id;
}

static ub1 *idnnam(ub4 x)
{
  return getkey(&idtab,x);
}

static void id2nam(ub2 id,ub1 *dst)
{
  ub2 ndx = id2nams[id];
  ub2 a,b;

  a = ndx >> id2shift1;
  b = ndx & id2mask1;

  dst[0] = a + id2loch1;
  dst[1] = b;
  dst[2] = 0;
}

const ub1 *idnam(ub4 id)
{
  static ub1 buf[4];

  if (id < B99_count) return bltnam(id,nil);
  else if (id < B99_count + D99_count) return dunnam(id - B99_count);
  else {
    id -= B99_count + D99_count;
    if (id < uid1cnt) { *buf = id1inv[id]; buf[1] = 0; return buf; }
    else if (id < uid1cnt + uid2cnt) { vrbo("id %u - %u",id,uid1cnt); id2nam(id - uid1cnt,buf); return buf; }
    else { vrbo("id %u - %u - %u",id,uid1cnt,uid2cnt); return getkey(&idtab,id - uid1cnt - uid2cnt); }
  }
}

static void mkid2tab(void) {
  ub2 c;
  ub2 n1=0,n2=0;
  ub1 x;

  id2chlen = id2hich1 = id2loch1;

  id2tab = (ub2 *)minalloc(id2chlen * 256,2,0xff,"lex id2tab");
  id2nams = (ub2 *)minalloc(id2nch1 * id2nch2 * 2,2,Mnofil,"lex id2nam");
}

ub4 slitstr(ub4 id,ub4 *plen)
{
  ub8 x8;
  ub4 pos,len;

  if (id > slitucnt) ice(hi32,"slit id %u above %u",id,slitucnt);
  if (id > slitidlen) ice(hi32,"slit id %u above %u",id,slitidlen);
  x8 = slitids[id];
  len = x8 >> 32;
  pos = x8 & hi32;
  if (pos >= slittop) ice(hi32,"slit pos %u above %u",pos,slittop);
  *plen = len;
  return pos;
}

// todo use cnt : file size
static void mkslithash(ub4 cnt)
{
  ub4 hlen;
  ub4 bit = 0;

  if (cnt < 16) hlen = cnt+64;
  else if (cnt > hi20) {
    warning("string lit count %u`",cnt);
    cnt = hi20;
    hlen = cnt * 2;
  } else hlen = cnt * 4;

  slithshlen = 1;
  while (slithshlen < hlen) { slithshlen <<= 1; bit++; }
  slithshmask = slithshlen-1;
  slithshbit = bit;

  slithsh = alloc(slithshlen,ub4,0,"lex slit hash",nextcnt);
  info("%u entry slit hash",slithshlen);
}

static ub4 slitcheck(ub1 *pool,ub4 nam0,ub4 nam1,ub4 v,ub1 ctl)
{
  ub4 x,np,id;
  ub4 l1,len = nam1 - nam0;

  if (v >= slithshlen)
    ice(0,"slit ndx %u above %u for %.*s",v,slithshlen,len,pool+nam0);

  x = slithsh[v];

  if (x == 0) { // slot free - consolidate pool
    id = ++slitucnt;
    if (id >= slitidlen) ice(0,"slit id %u above %u",id,slitidlen);
    slithsh[v] = id;
    np = slitpos;
    slitpos = nam1 + 1;
    if (slitpos >= slittop) ice(0,"slit pos %u above top %u",nam1,slittop);
    slithshcnt++;
    slitids[id] = np | ((ub8)len << 32);
    // vrb("add slit len %u pos %u '%s' id %u ctl %u",len,np,chprintn(pool+nam0,min(len,64)),id,ctl);
    return id; // new

  } else {
    if (x >= slitidlen) ice(0,"slit id %u/%u above %u for v %u '%.*s'.%u",x,slitucnt,slitidlen,v,len,pool+nam0,len);
    l1 = slitids[x] >> 32;
    np = slitids[x] & hi32;
    // info("v %u x %u nam0 %u top %u",v,x,nam0,slittop);
    if (l1 == len && memcmp(pool + np,pool + nam0,len) == 0) return x;
    else {
      slithshmis++;
      return 0;
    }
  }
}

// get or if none insert. len > 2
static ub4 slitgetadd(ub4 fps,ub1 *pool,ub4 nam1,ub1 ctl)
{
  ub4 nam0 = slitpos;
  ub4 len = nam1 - nam0;
  ub4 v;
  ub4 x,id;
  ub4 hc,hc2;
  ub2 lim;

  if (nam1 >= slittop) ice(0,"slit pos %u above top %u",nam1,slittop);
  pool[nam1] = 0;
  if (len == 3) {
    hc = hash32(pool+nam0,3);
  } else if (len >= Slitint || slitucnt * 2 > slithshlen) { // skip if long or table loaded
    slitpos = nam1 + 1;
    if (slitpos >= slittop) ice(0,"slit pos %u above top %u",nam1,slittop);
    id = ++slitucnt;
    slitids[id] = nam0 | ((ub8)len << 32);
    if (len > slithilen) { slithilen = len; slithipos = fps; }
    return id;
  } else {
    hc = hashstr(pool+nam0,len,Hshseed);
    hc = (hc >> slithshbit) ^ hc;
  }
  v = hc & slithshmask;

  x = slitcheck(pool,nam0,nam1,v,ctl);
  if (x) {
    return x;
  } else { // probe once with second hash
    hc2 = hc >> slithshbit;
    v = (v + hc2) & slithshmask;
    if (v >= slithshlen) v -= slithshlen;
    x = slitcheck(pool,nam0,nam1,v,ctl);
    if (x) {
      info("add slit %u len %u '%s'",x,len,pool + nam0);
      return x;
    } else {
      slitpos = nam1 + 1; // skip dedup
      id = ++slitucnt;
      if (id >= slitidlen) ice(0,"slit id %u above %u",id,slitidlen);
      slitids[id] = nam0 | ((ub8)len << 32);
      info("add slit %u len %u '%s' pos %u",id,len,pool+nam0,nam0);
      return id;
    }
  }
}

#if Kwcnt > 0
static inline enum token lookupkw(const ub1 *nam,ub1 len,ub4 hc)
{
  ub1 x,m;
  ub4 ndx;
  enum token kw;

  if (len > hikwlen) return t99_count;
  else if (len >= mikwlen) m = 0xf0;
  else m = 0xf;

  x = kwhshlut[hc & 0xff]
      | kwhshlut[(hc >> 8) & 0xff]
      | kwhshlut[(hc >> 16) & 0xff]
      | kwhshlut[hc >> 24];

  if ( (x & m) != m) return t99_count;

  hc = (hc >> Kwhshbit) ^ hc;
  hc = Kwhshshift(hc);
  ndx = hc & Kwhshmsk;

  kw = kwhsh[ndx];
  if (kw == t99_count) return t99_count;

  if (tkwnamlens[kw] == len && memcmp(nam,tkwnampool + tkwnamposs[kw],len) == 0) return kw;
  else return t99_count;
}
#endif

#ifdef Bltcnt
static inline enum Bltin lookupblt(const ub1 *nam,ub2 len,ub4 hc)
{
  ub1 ndx,x,m;
  enum Bltin bt;

  if (len > hibltlen) return B99_count;
  else if (len >= mibltlen) m = 0xf0;
  else m = 0xf;

  x = blthshlut[hc & 0xff]
      | blthshlut[(hc >> 8) & 0xff]
      | blthshlut[(hc >> 16) & 0xff]
      | blthshlut[hc >> 24];

  if ( (x & m) != m) return B99_count;

  hc = (hc >> Blthshbit) ^ hc;
  hc = Blthshshift(hc);
  ndx = hc & Blthshmsk;

  bt = blthsh[ndx];
  if (bt == B99_count) return B99_count;

  if (bltnamlens[bt] == len && memcmp(nam,bltnampool + bltnamposs[bt],len) == 0) return bt;
  else return B99_count;
}
#else
  #define lookupblt(nam,len,hc) B99_count
#endif

#ifdef Duncnt
static inline enum Dunder lookupdun(const ub1 *nam,ub2 len)
{
  ub4 hc;
  ub1 ndx;
  enum Dunder dun;

  if (len > hidunlen) return D99_count;

  ub4 seed,mask;
  ub2 bit;
  const enum Dunder *hsh;

  if (*nam & 1) {
    seed = Hshd1seed;
    bit = Dun1hshbit;
    mask = Dun1hshmsk;
    hsh = dun1hsh;
  } else {
    seed = Hshd0seed;
    bit = Dun0hshbit;
    mask = Dun0hshmsk;
    hsh = dun0hsh;
  }
  // info("dun '%.*s'.%u",len,idp,len);
  hc = hashstr(nam,len,seed);
  hc = (hc >> bit) ^ hc;

  if (*nam & 1) hc = Dn0hshshift(hc);
  else hc = Dn1hshshift(hc);

  ndx = hc & mask;

  dun = hsh[ndx];

  // info("tbl %u ndx %x dun %u",*nam & 1,ndx,dun);
  if (dun == D99_count) return D99_count;

  if (dunnamlens[dun] == len && memcmp(nam,dun0nampool + dunnamposs[dun],len) == 0) return dun;
  else return D99_count;
}
#else
  #define lookupdun(len,hc) D99_count
#endif

static ub1 lxatox1(ub1 c)
{
  ub1 x;

  if (c >= '0' && c <= '9') x = c - '0';
  else if (c >= 'A') x = (c | 0x20) - 'a' + 10;
  else return 0xff;
  return x;
}

static ub4 doescx(const ub1 * restrict src,ub4 sn,ub1 *pool,ub4 *plitx,bool isbin)
{
  ub4 litx = *plitx;
  ub1 x,x1,x2,c = src[sn],d = src[sn+1];

  x1 = lxatox1(c);
  x2 = lxatox1(d);

  if ( (x1 | x2) > 0xf) { swarn(0,"illegal hex escape seq '%s%s'",chprint(c),chprint(d)); return sn; }

  x = x1 << 4 | x2;

  if (x < 0x80 || isbin) pool[litx++] = x;
  else { // utf8
    pool[litx]   = 0xc0 | (x >> 6);
    pool[litx+1] = 0x80 | (x & 0x3f);
    litx += 2;
  }
  *plitx = litx;
  return sn+2;
}

static ub4 doescu(const ub1 * restrict src,ub4 sn,ub1 *pool,ub4 *plitx,ub1 ctl)
{
  ub4 litx = *plitx;

  pool[litx] = *src;
  switch(ctl) {
  case 'U': serror(sn,"\\Uxx.. in  string lits at pos %u TODO",litx);
  case 'u': serror(sn,"\\uxx.. in  string lits at pos %u TODO",litx);
  }
  return sn+1;
}

static ub4 doescn(const ub1 * restrict src,ub4 sn,ub1 *pool,ub4 *plitx)
{
  ub4 litx = *plitx;
  ub4 s0 = sn,len;
  ub1 c;

  do {
    c = src[sn++];
  } while ( (c >= 'A' && c <= 'Z') || c == ' ' || c == '-');
  len = sn - s0;
  memcpy(pool + litx,src + s0,len);
  litx += len;
  if (c == '}') { // named unicode todo
  }
  *plitx = litx;
  return sn;
}

#define Dent 256

static ub4 tkstats[T99_count];

static void doemit(struct lexsyn *lsp,ub4 *lntab,bool emit,bool pretty,bool log)
{
  const enum Token *tks = lsp->toks;
  const ub2 *atrs = lsp->atrs;
  const ub8 *bits = lsp->bits;
  const ub4 *cmts = lsp->cmts;
  const cchar *src = lsp->src;
  const ub1 *dfp0s = lsp->dfp0s;
  const ub1 *dfp1s = lsp->dfp1s;
  cchar *name = "todo";

  ub4 tkcnt = lsp->tkcnt;
  ub4 tbcnt = lsp->tbcnt;
  ub4 cmcnt = lsp->cmtcnt;
  const ub1 *slitpool = lsp->slitpool;

  enum Token tk=0,rtk;
  ub2 atr,at;
  ub4 dn,bn=0,ncmt=0,dnn=0;
  ub8 x8=0;
  ub4 x4,cmt0,i;
  ub4 lno = 0,plno = 0,clno = 0;
  ub4 col;
  ub2 dent=0;
  ub4 bitatr;
  ub4 id;

  ub4 fps=0,xat;
  ub4 dfp;
  ub1 dfp0,dfp1;
  ub4 fn0=0,fn1=0;

  ub4 pos;
  ub4 slen=0,clen,len,nlen,blen = 4090;
  ub4 n2,n3;
  char buf[4096];
  char sbuf[4096];
  char buf2[Idlen+64];
  char c,d,e,sign=' ',Q=0;
  char qs[4];
  ub2 nQ=0;
  cchar *tval;
  cchar *tnam;
  cchar *sp=nil;
  cchar *p;
  bool isprv;
  struct bufile fp;
  char ppnam[1024];

  if (pretty) {
    sp = strrchr(name,'.');
    if (sp) len = sp - name;
    else { len = strlen4(name); sp = ".py"; }
    mysnprintf(ppnam,0,1024,"%.*s.pretty%s",len,name,sp);
    fp.nam = ppnam;
    fp.dobck = 1;

    myfopen(FLN,&fp,16384,1);
    info("writing %s",ppnam);
    msgfls();
  }

  if (emit && name) msglog(name,"tks","lex");

  for (dn = 0; dn < tkcnt; dn++) {
    rtk = tks[dn];
    atr = atrs[dn];

    if (rtk & 0x80) {
      tk = rtk & 0x3f;
      dfp0 = dfp0s[fn0++];
      dfp = dfp0 & 0x7f;
      if (dfp0 & 0x80) {
        dfp |= dfp0s[fn0++] << 7;
        dfp |= dfp0s[fn0++] << 15;
      }
      fps += dfp;
    } else {
      tk = rtk;
    }

    if (rtk & 0x40) {
      dfp1 = dfp1s[fn1++];
      if (dfp1 & 0x80) {
      }
    }

    xat = 0; // todo

    while (fps >= lntab[lno]) lno++;
    while (lno && lntab[lno] > fps) lno--;

    if (lno) { col = fps - lntab[lno]; }
    else col = fps;

    c = d = ' '; tval = ""; pos = 0; isprv = 0;
    if (tk >= T99_count) ice(fps,"pos %u/%u - invalid token %u",dn,tkcnt,tk);
    tnam = tknam(tk);
    // sinfo(fps,"tk %u '%s' bn %u dn %u",tk,tnam,bn,dn);
    nlen = len = strlen(tnam);

    if (tbcnt && tk >= T99_kwd && tk <= T0grp) {
      if (bn > tbcnt) ice(0,"value pos %u above %u",bn,tbcnt);
      x8 = bits[bn];
      bitatr = x8 >> 32;
      x4 = x8;
      // sinfo(fps,"dn %u bn %u bits %u.%x",dn,bn,bitatr,x4);
    } else {
      bitatr = 0;
      x4 = 0;
    }

#ifdef Emitdetail
    if (tk > T0grp) tval = tnam;
    at = atr & ~La_msk; atr &= La_msk;

    switch (tk) {

    case Tid:
      len = Idlen; x4 = hi32; c = ' '; tval = buf2;
      if (at & La_idprv) { isprv = 1; at &= ~La_idprv; }
      switch(at) {
      case 0:      d = '0'; x4 = atr; tval = idnnam(x4); // id4s
      break;

      case La_id1: d = '1'; c = id1inv[atr]; if (pretty) { buf2[0] = c; len=1; } break;
      case La_id2: d = '2'; id2nam(atr,buf2); len = 2; break;
      case La_id4: d = '4'; x4 = x8;
        // vrbo("ln %u id4 bn %u id %u",bitln,bn,x4);
        if (bitatr != dn) ice(fps,"id tk %u vs bit %u %lx at %u %s",dn,bitatr,x8, bn,cursrc);
        tval = idnnam(x4);
        // sinfo(fps," id id tk %3u bit %3u %2u %8s %c %c %s%.*s",dn,bn,tk,tnam,c,d,isprv ? "__" : "",len,tval);
        bn++;
      break;

      case La_idblt: d = 'b'; tval = bltnam(atr,&len); break;

      case La_iddun: d = 'd'; tval = buf; len = mysnprintf(buf,0,Idlen+4,"__%s__",dunnam(atr)); break;

      default: ice(fps,"unhandled atr %x id tk %u bit %u %s",at,dn,bn,cursrc);
      }
      // sinfo(fps," id id tk %3u bit %3u %2u %8s %c %c %s%.*s",dn,bn,tk,tnam,c,d,isprv ? "__" : "",len,tval);
    break;

    case Tnlit:
      if (at & (1U << La_bit)) { sign = '-'; at &= 0xe000; }
      else sign = ' ';
      tval = buf;
      c = 'i'; d = 'b';
      switch (at) {
      case La_flit8:
        c = 'f';
        // info("flit8 bn %u",bn);
        len = mysnprintf(buf,0,blen,"%u.0",x4 & hi16);
        bn++;
        break;
      case La_flita: c = 'f'; Fallthrough
      case La_ilita: d = 'a';
        len = mysnprintf(buf,0,blen,"%.*s",atr,src + x4);
        bn++;
        break;
      case La_ilit4:
        if (bitatr != dn) {
          if (pretty) myfclose(&fp);
          ice(fps,"ilit4 ti %u vs bit %u at %u %u %s",dn,bitatr,bn,x4,cursrc);
        }
        bn++;
        len = mysnprintf(buf,0,blen,"%u",x4);
        // vrbo("ln %u nlit bn %u %u",bitln,bn,x4);
        break;

      default:
        x4 = atr;
        len = mysnprintf(buf,0,blen,"%u",x4);
      }
    break;

    case Tslit: tval = buf;
      if (xat & 32) buf[pos++] = 'f';
      Q = (xat & 8) ? '"' : '\'';
      qs[0] = Q;
      if (xat & 16) {
        qs[1] = qs[2] = Q;
        nQ = 3;
      } else nQ = 1;
      qs[nQ] = 0;
      if (xat & 4) buf[pos++] = 'b';
      if (xat & 2) buf[pos++] = 'f';
      if (xat & 1) buf[pos++] = 'r';
      // info("slit at %x",at);

      switch (at) {
      case 0:        slen = 1; e = atr; sp = (cchar *)&e; break; // slit 1
      case La_slit0: slen = 0; sp = ""; break;
      case La_slit2: slen = 2; sp = buf2;
        if (bitatr != dn) ice(fps,"slit tk %u vs bit %u at %u %s",dn,bitatr,bn,cursrc);
        buf2[0] = x4 & 0xff;
        buf2[1] = x4 >> 8;
        /* vrbo("ln %u slit2 bn %u '%.2s'",bitln,bn,sp); */ bn++; break;
      case La_slits:
      case La_slit:
        if (at == La_slits) id = atr;
        else {
          if (bitatr != dn) ice(fps,"slit tk %u vs bit %u at %u %s",dn,bitatr,bn,cursrc);
          id = x4; bn++;
          // vrbo("ln %u id bn %u",bitln,bn);
        }
        x4 = slitstr(id,&slen);
        sp = slitpool + x4;
        break;

      default: ice(fps,"unhandled atr %x id tk %u bit %u %s",at,dn,bn,cursrc);
      }
      if (slen > 4 && sp[0] == '.' && sp[1] == '/') { vrbo("%.*s",slen,sp); slen = min(slen,sizeof(cursrc)-1); memcpy(cursrc,sp,slen); cursrc[slen] = 0; }
    break;

    case Top:
      tnam = "op";
      c = atr & 0xff; tval = buf2;
      buf2[0] = c; len = 1;
      if (atr & Lxop2) buf2[len++] = c;
      if (atr & Lxoe) buf2[len++] = '=';
      // sinfo(fps," op '%.*s' ",len,tval);
    break;

    case Taas:
      c = atr & 0xff; tval = buf2;
      buf2[0] = c; len = 1;
      if (atr & Lxop2) buf2[len++] = c;
      buf2[len++] = '=';
    break;

    case Tsepa: if (atr == 0) { tval = buf2; buf2[0] = '\n'; len = 1; plno++; } break; // at eol

    default: break;
    }
#endif

#ifdef Emitdetail
    if (pretty) {
      while (ncmt + 1 < cmcnt && cmts[ncmt] < fps) { // comment

        cmt0 = cmts[ncmt++];
        clen = cmts[ncmt++] - cmt0;

        while (cmt0 >= lntab[clno]) clno++;
        while (clno && lntab[clno] > cmt0) clno--;

        while (plno < clno) { myfputc(&fp,'\n'); plno++; }

        if (clen) myfwrite(&fp,src + cmt0,clen);
        plno++;
        // info("cmt %u fps %u-%u len %u '%s'",ncmt,cmt0,cmts[ncmt-1],slen,chprintn(src + cmt0,min(clen,64)));
      }
      if (plno < lno && *tval != '\n') { // empty lines
        while (plno < lno) { myfputc(&fp,'\n'); plno++; }
        if (dent) myfprintf(&fp,"%*s",dent,"");
      }

      if (isprv) myfputs(&fp,"__");
      if (tk < T99_kwd) {
        if (tk >= T99_mrg) { tnam = tkwnampool + tkwnamposs[atr]; nlen = tkwnamlens[atr]; }
        myfwrite(&fp,tnam,nlen);
      } else if (tk == Tid) {
        if (len == Idlen) len = strlen(tval);
        myfwrite(&fp,tval,len);
      } else if (tk == Tnlit) {
//        info("ln %u c %c len %u %.*s",lno,*tval,len,len,tval);
        while (len && (*tval == '-' || *tval == '+')) { tval++; len--; }
        myfwrite(&fp,tval,len);
      } else if (tk == Tslit) {
        myfprintf(&fp,"%.*s%s",pos,buf,qs); pos = 0; i = 0; // prefix + open q
        while (i < slen) {
          n2 = min(slen-i,1024);
          n3 = chprintn(sp + i,n2,sbuf,xat);
          i += n2;
          myfwrite(&fp,sbuf,n3);
        }
        myfwrite(&fp,qs,nQ);
      } else if (len == 1) myfputc(&fp,*tval);
      else if (len) myfwrite(&fp,tval,len);
      myfputc(&fp,' ');
    } // pretty
#endif

    if (emit | log) {
#ifdef Emitdetail
      switch (tk) {
      case Tnlit:
        info("%s.%3u.%-2u: %3u %2u %8s %c %c %c%.*s",name,lno,col,dn,tk,tnam,c,d,sign,len,tval);
        break;
      case Tslit:
        chprintn(sp,min(slen,64),sbuf,xat & ~16);
        info("%s.%3u.%-2u: %3u %2u %8s %c %c len %u %c%s%c",name,lno,col,dn,tk,tnam,c,d,slen,Q,sbuf,Q);
        if (slen > 64) {
          chprintn(sp + slen - 64,64,nil,xat & ~16);
          info("%s.%3u.%-2u: %3u %2u %8s ... '%s'",name,lno,col,dn,tk,tnam,sbuf);
        }
        break;
      case Tco: case Tcc: case Tro: case Trc:
        info("%s.%3u.%-2u: %3u %2u %8s %c %c %s lvl %u",name,lno,col,dn,tk,tnam,c,d,tnam,atr);
        break;
      default: info("%s.%3u.%-2u: %3u %2u %8s %c %c %.*s",name,lno,col,dn,tk,tnam,c,d,len,tval);
      }
#else
      info("%3u %-8s %u",dn,tnam,tk);
#endif
    }

    fps++;
  } // each tk
  sinfofln(FLN,lsp->srclen,"EOF");

  if (pretty) {
    myfputc(&fp,'\n');
    myfclose(&fp);
    info("wrote %s",ppnam);
    showcnt("ptoken",dnn);
    msgfls();
  }

  if (emit) {
    msglog(nil,nil,"lex");
    showcnt("bit",bn);
  }
}

static ub4 rdfid(const ub1 *p)
{
  ub4 f = *p | p[1] << 8 | p[2] << 16;
  return f;
}

enum Tkpart { Tp_dfp0,Tp_dfp1,Tp_tk,Tp_atr,Tp_ctl,Tp_bit,Tp_cmt,Tp_cnt };

int lex(struct prelex *presp,struct lexsyn *lsp,ub8 T0)
{
  int rv = 0;

  ub8 T1=T0;

  timeit(&T1,nil);

  ub4 t1 = T1 / 1000;

  ub4 len;
  ub2 len2;

  const ub1 *sp;
  const ub1 *srcbas = presp->src;
  ub4 slen = presp->srclen;

  // tokens
  enum Token tk=0,rtk;
  enum Bltin blt;
  enum Dunder dun;

  ub4 tkcnt=0;
  ub4 tacnt;

  ub1 ctl=0;
  ub2 atr=0;

  ub4 cmt0,ncmt=0; // comment

  struct mempart tkpart[Tp_cnt];

  ub1 grp;

  // files
  ub4 fid;

  // str lits
  ub1 *slitpool=nil;
  ub4 slitx=0;
  ub1 slitctl=0;

  // ids
  const ub1 *idp;
  ub4 idcnt=0,id1cnt=0,id2cnt=0,euidcnt=0;

  // kwd, bltin, dunder
  ub4 kwcnt=0;
  ub4 bltcnt=0;
  ub4 duncnt=0;

  // str lits
  ub4 slitcatcnt=0;

  // int lits
  ub4 ilitcnt=0,ilit1cnt=0;
  ub4 ipart4;

  bool litbin = 1;
  bool litfpi=0;
  ub1 ilitctl = 0;

  // flt lits
  ub4 flitcnt=0;
  ub4 fdp=0; // dot pos
  ub2 fxp=0; // e+nn
  bool fxs=0; // exp sign
  ub2 exdig=0;

  // indent
  ub2 dentst[Dent];
  ub2 dent;
  ub2 dentlvl=0;

  // braces
  ub4 bolvls[Depth];
  ub1 bolvlc[Depth];
  ub2 bolvl=0,fsxplvl=hi16;
  ub2 colvl=0,solvl=0,rolvl=0;
  ub2 rocnt=0,rccnt=0,cocnt=0,cccnt=0,socnt=0,sccnt=0;

// line/col/dent
  ub4 l=0;
  ub4 nlcol=0;
  ub4 *lntab=nil;
  bool docol=1;

  ub4 i,cnt;

  ub1 c,prvc1,prvc2,signc;

  ub4 dn,bn = 0,dn1=0;
  ub4 an=0,cn=0;

  ub4 fn0=0,fn1=0;
  ub4 n = 0;
  ub4 fps,dfp;

  ub4 idnplen=0;

  dentlvl=0;
  memset(dentst,0,sizeof(dentst));

  ub1 t=0;

  ub1 Q = 0,orgQ = 0;
  ub4 N = 0;
  ub1 R0 = 0,R1 = 0,R2 = 0,R3 = 0,orgR0=0;
  ub1 sign = 0;
  ub4 prvN=0,prvn=0;
  ub4 dfp0,dfp1;
  ub4 id=0;
  ub1 x1;
  ub4 x4;
  ub8 i8;
  ub1 sla;

  ub4 hc=0;

  enum token kw;
  ub4 idhilen = 0;

  memset(bolvlc,0,Depth);

  /* alloc slen * 1 tks + dfp0,1
           slitatr: raw.1, q.1 lvl.3 id.1 len.2
  */
  ub4 lncnt    = presp->lncnt;
  ub4 modcnt   = presp->modcnt;
  ub4 slitncnt = presp->slitncnt;
  ub4 slit1cnt = presp->slit1cnt;
  ub4 slit2cnt = presp->slit2cnt;
  ub4 slitcnt  = slitncnt + slit1cnt + slit2cnt;

  ub4 nlitcnt = presp->nlitcnt;

  ub4 bitcnt = presp->bitcnt;

  ub4 estacnt = presp->tacnt + slitcnt + nlitcnt + modcnt;
  ub4 estkcnt = presp->tkcnt + slitcnt + nlitcnt + estacnt + 4 * modcnt;
  ub4 cmtcnt  = presp->cmtcnt;

  for (i = 0; i < Tp_cnt; i++) {
    tkpart[i].siz = 1;
    tkpart[i].fil = Mnofil;
    tkpart[i].nel = estkcnt;
  }
  tkpart[Tp_ctl].fil = 0;

  tkpart[Tp_atr].nel = estacnt;
  tkpart[Tp_ctl].nel = slitcnt + nlitcnt;
  tkpart[Tp_cmt].nel = cmtcnt;
  tkpart[Tp_bit].nel = bitcnt;

  len = min(slen / 2,estkcnt * 3);
  tkpart[Tp_dfp0].nel = max(len,32);
  tkpart[Tp_dfp1].nel = max(len,32);

  tkpart[Tp_atr].siz = 2;
  tkpart[Tp_cmt].siz = 4;
  tkpart[Tp_bit].siz = 8;

  tkpart[Tp_dfp0].dsc = "dfp0";
  tkpart[Tp_dfp1].dsc = "dfp1";
  tkpart[Tp_tk].dsc = "tk";
  tkpart[Tp_atr].dsc = "atr";
  tkpart[Tp_cmt].dsc = "cmt";
  tkpart[Tp_ctl].dsc = "ctl";
  tkpart[Tp_bit].dsc = "bit";

  ub1 *tkbas = allocset(tkpart,Tp_cnt,Mnofil,"lex tokens",nextcnt);
  ub1 *dfp0s = tkpart[Tp_dfp0].ptr;
  ub1 *dfp1s = tkpart[Tp_dfp1].ptr;
  ub1 *tks   = tkpart[Tp_tk].ptr;
  ub2 *atrs  = tkpart[Tp_atr].ptr;
  ub4 *cmts  = tkpart[Tp_cmt].ptr;
  ub1 *ctls  = tkpart[Tp_ctl].ptr;
  ub8 *bits  = tkpart[Tp_bit].ptr;

  struct filinf *fip,*fips = presp->files;

  if (idcnt) {
    if (euidcnt == 0) euidcnt = idcnt;
    mkmap(&idtab,euidcnt * 4,euidcnt * 4);
  }
  if (id2cnt) {
    mkid2tab();
  }
  memset(id1tab,0xff,256);

  // slits
  ub4 sltop = presp->slittop;

  if (slitncnt) {
    sltop += slitcnt; // 0-term
    slitpool = minalloc(sltop,1,Mnofil,"lex slitpool");
    showsiz("slit pool",sltop);
    slittop = sltop;
    mkslithash(slitncnt);

    slitidlen = slitcnt;
    slitids = minalloc(slitidlen * 8,8,Mnofil,"lex slitids");
  }

  ub4 lntabsiz = (lncnt+1) * 4;

  lntab = minalloc(lntabsiz,4,Mnofil,"lex lntab");
  // setsrcmfile(mf,lntab,lncnt,n);

  dn = 0;
  an = 0;
  cn = 0;
  bn = 0;

  info("+lex %u",gettime_msec()-t1);

  fid = 0;

// ---------------
nxtfil:
// ---------------

  fip = fips + fid;
  n = fip->pos;
  sp = srcbas + fip->src;
  slen = fip->len;
  n = 0;

  if (fip->typ) {
//    tks[dn++] = Tmodul;
//    tks[dn++] = Tid;
    tks[dn++] = Tco;
//    atrs[an++] = La_mid | fip->modid;
  }

#undef  FLN
#define FLN __LINE__|(Shsrc_lex1<<16)

#include "lextab.i"

#undef  FLN
#define FLN __LINE__|(msgfile<<16)

  // come here at eof for each included file

  if (fip->typ) {
    tks[dn++] = Tcc;
  }

  fip->pos = n;
  fid = rdfid(sp+slen);

  if (fid != hi32) goto nxtfil;

// ---------------
end:
// ---------------

  if (verbose) timeit2(&T1,slen,"pass 1 tokenised ` in");

  info("-lex %u",gettime_msec()-t1);
  tkcnt = dn;
  tacnt = an;

  showcnt("04xtoken",tkcnt);
  showcnt("04atoken",tacnt);
  showcnt("04line",l);

  if (lncnt != l) warning("lncnt %u vs %u",l,lncnt);

  showcnt("04int 1 lit",ilit1cnt);
  showcnt("04int n lit",ilitcnt);
  showcnt("04flt n lit",flitcnt);

  if (n < slen) warning("len %u vs %u",n,slen);
  else if (n > slen + 4) warning("len %u vs %u",n,slen);

  slitcnt += slit0cnt + slit1cnt;
  showcnt("04slit",slitcnt);

  showcnt("04ident / kwd",idcnt);

  bitcnt += idcnt;

  showcnt("04value",bitcnt);

  if (tkcnt < 2) { // nl->semi
    info("%s is empty",lsp->name);
    return 0;
  }

  showcnt("04ident2",id2cnt);
  showcnt("04ident1",id1cnt);

  showcnt("04token",tkcnt);
  showcnt("04total 1",dn1);

  if (tkcnt > estkcnt) ice(n,"token count %u exceeds estimate %u",tkcnt,estkcnt);

  showcnt("colvl",colvl);
  showcnt("solvl",solvl);
  showcnt("rolvl",rolvl);

  showcnt("4ro",rocnt);
  showcnt("4co",cocnt);

  showcnt("4cmt",ncmt);

  if (globs.rununtil == 2) { info("until lex pass 1 %u",gettime_msec()-t1); return 0; }

  if (verbose) timeit2(&T1,slen,"pass 2 tokenised `B in");

  showcnt("3token",dn);
  showcnt("3line",l);

  if (n != slen + 1) warning("src len %u vs %u",n,slen);

  showcnt("bltin",bltcnt);
  showcnt("dunder",duncnt);

  if (idcnt) {
//    info("%3u` uniq idents, est %u` max len %u",idhshcnt,euidcnt,idnmax);
//    info("id hash table used %u` of %u` retry %u`",idhshcnt,idhshlen,idhshmis);
    finmap(&idtab);
  }
  showcnt("3 ident",idcnt);
  showcnt("3uident",uidcnt);

  showcnt("3 ident1",id1cnt);
  showcnt("3uident1",uid1cnt);

  showcnt("3 ident2",id2cnt);
  showcnt("3uident2",uid2cnt);

  if (slithshcnt) {
    showcnt("3hash slit",slithshcnt);
    showcnt("3uniq slit",slitucnt);
    sinfo(slithipos,"longest slit len %u",slithilen);
    info("slit hash table used %u` of %u` retry %u` skipped %u`",slithshcnt,slithshlen,slithshmis,slitlimcnt);
    afree(slithsh,"lex slit hash",nextcnt);
  }
  showcnt("3slit concat",slitcatcnt);

  showcnt("3value",bn);

  if (tkcnt < slitcatcnt) {
    error("%u slit concat vs %u :1 tokens",slitcatcnt,tkcnt);
    return 1;
  }
  tkcnt -= slitcatcnt;

  if (dn > tkcnt) {
    error("%u :1 vs %u :2 tokens dif %u",tkcnt,dn,dn - tkcnt);
    rv = 1;
  } else if (dn < tkcnt) {
    warning("%u :1 vs %u :2 tokens dif %u",tkcnt,dn,tkcnt - dn);
    rv = 0;
  }

  tkcnt = dn;

  if (l > lncnt) {
    error("%u :1 vs %u :2 lines",lncnt,l);
    return 1;
  } else if (l < lncnt) {
    warning("%u :1 vs %u :2 lines",lncnt,l);
  }
  lntab[l] = n+1;

  memset(tks+tkcnt,T99_eof,Tkpad);

  lsp->idcnt = idcnt;
  lsp->id1cnt = id1cnt;
  lsp->id2cnt = id2cnt;

#if 0
  kwcnt = 0;
  for (dn = 0; dn < tkcnt; dn++) {
    tk = tks[dn];
    tkstats[tk]++;
  }
  cnt1 = 0;
  for (tk = 0; tk < T99_count; tk++) {
    cnt  = tkstats[tk];
    if (cnt) {
      cnt1 += cnt;
#if Kwcnt > 0
      if (tk < T99_kwd) kwcnt += cnt;
#endif
    }
  }
  showcnt("4total",cnt1);
  showcnt("4kwd",kwcnt);

  for (tk = 0; tk < T99_count; tk++) {
    cnt  = tkstats[tk];
    if (cnt) {
#if Kwcnt > 0
      if (tk < T99_kwd) kwcnt += cnt;
#endif
      info("%5u %s",cnt,tknam(tk));
    }
  }
#endif

  lsp->nlitcnt = ilitcnt + flitcnt + ilit1cnt;

  lsp->src = sp;

  showcnt("3token",dn);
  showcnt("3bit",bn);

  lsp->tkcnt = dn;
  lsp->tbcnt = bn;

  lsp->toks = tks;
  lsp->bits = bits;
  lsp->atrs = atrs;
  lsp->dfp0s = dfp0s;
  lsp->dfp1s = dfp1s;

  lsp->uidcnt = uidcnt;
  lsp->uid1cnt = uid1cnt;
  lsp->uid2cnt = uid2cnt;

  lsp->idtab = &idtab;

  lsp->slitpool = slitpool;
  lsp->slitcnt = slitcnt;
  lsp->slittop = slittop;
  lsp->slithilen = max(slithilen,Slitint);

  lsp->cmts = cmts;
  lsp->cmtcnt = ncmt;

  lsp->tkbas = tkbas;

  bool emit = globs.emit & 1;
  bool dolog = globs.log & 1;
  bool pretty = 0; // globs.emit >> 15;

  if (emit | pretty | dolog) doemit(lsp,lntab,emit,pretty,dolog);

  return rv;
}

cchar *lex_info(void) {
  return lexinfo;
}

void inilex(void)
{
  ub4 hc,i;

  verbose = globs.msglvl >= Vrb;

  sassert(sizeof(esctab) == 128,"short enums required");

  genmsgfln(0,Info,"%s\n",lexinfo);

  // check genlex used same hash as us
#if Kwcnt > 0
  i = sizeof(tkwnampool);
  hc = hashalstr(tkwnampool,i,Hshseed);
  if (hc != kwnamhsh) {
    ice(0,"lexer inconsistent kwd hash %s: %x versus genlex: %x len %u seed %x '%.*s'",globs.prgnam,hc,kwnamhsh,i,Hshseed,i,tkwnampool);
  }
#endif

  lastcnt
}
