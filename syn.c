/* syn.c - syntax analysis aka parsing

   This file is part of Luanova, a fresh implementation of Lua.

   Copyright Â© 2022 Joris van der Geer.

   Luanova is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Luanova is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU Affero General Public License
   along with this program, typically in the file License.txt
   If not, see http://www.gnu.org/licenses.
 */

/* This is a table-driven predictive top-down aka LL(1-2) parser.
   The tables are generated by gensyn from a grammar and token definitions.
   Input is a complete token stream as array with attributes, values and file coords.
   Lexical analysis completes before parsing starts.
   The lexer is responsible for checking brackets and quotes to balance.
   Thus, only genuine synatx errors are expected.

   The tables describe an additional token of lookahead for otherwise ambiguous productions.

   Output is a list of nodes with type, type-specific index and attributes
   A tree is inferrable from a list of arguments aka child nodes that point to a node and a parent node
   Storable node such as literals and identifers have an additinal value field.
 */

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include "base.h"
#include "chr.h"

#include "mem.h"

#include "fmt.h"

static ub4 msgfile = Shsrc_syn;
#include "msg.h"

#include "map.h"

#include "tok.h"

#include "lexsyn.h"
#include "lsa.h"

#include "syn.h"

#include "syndef.h" // generated by gensyn

#include "astyp.h"

#include "syntab.i" // generated by gensyn

#include "synast.h"

extern int syn(struct lexsyn *lsp,struct synast *sa,ub8 T0);

#ifdef __clang__
 #pragma clang diagnostic ignored "-Wenum-conversion"
 #pragma clang diagnostic ignored "-Wswitch-enum"
#elif defined __GNUC__
 #pragma GCC diagnostic ignored "-Wunused-variable"
#endif

#define Depth 128

#define Emitdetail

#define Trace

static bool dotrace = 0;

static cchar *tknam(enum Token tk,ub4 bits)
{
  ub2 len;
  ub1 hc;
  char *p,*q;
  static char basbuf[8 * 32];
  char *buf;
  static ub2 bufno;

  buf = basbuf + bufno * 32;
  bufno = (bufno + 1) & 7;

  if (tk >= T99_count) return "Tinv";
#if Kwcnt > 0
  else if (tk < T99_kwd) {
    memcpy(buf,kwnampool + kwnamposs[tk],len=kwnamlens[tk]);
    buf[len] = 0;
    buf[len+1] = ' ';
  }
#endif
  else {
    tk -= T99_kwd;
    hc = tokhrctl[tk];
    len = hc & 0xf;
    if (len == 0) return toknampool + toknampos[tk];
    p = hrtoknams + tk * 4;
    q = buf;
    if (bits == hi32) hc = 0;
    else hc >>= 4;
    while (len--) {
      if (hc & 1) *q = bits & 0xf;
      else *q = *p;
      p++; q++;
      hc >>= 1; bits >>= 8;
    }
    *q = 0;
    q[1] = ' ';
  }
  return buf;
}

static cchar *mrgnam(ub2 m,char sep)
{
  ub4 mrg = 1U << m;
  enum Token t;
  ub4 pos = 0,len = 255;
  static char basbuf[256 * 4];
  char *buf;
  static ub2 bufno;

  buf = basbuf + + bufno * 256;
  bufno = (bufno + 1) & 3;

  for (t = 0; t < T99_count; t++) {
    if (tkmrgtab[t] & mrg) {
      if (pos) buf[pos++] = sep;
      pos += mysnprintf(buf,pos,len,"%s",tknam(t,hi32));
    }
  }
  return buf;
}

static cchar *ntnam(enum Nterm n)
{
  if (n < Ncount) return ntnampool + ntnampos[n];
  else return "*Ninv*";
}

static cchar *symnam(enum Symbol s)
{
  if (s < Stoken) return tknam((enum Token)s,0);
  else if (s < Smrgset) return ntnam(s - Stoken);
  else if (s < Scount) return mrgnam(s - Smrgset,'|');
  else return "Seof";
}

static cchar *prdnam(enum Production p,enum Token tk)
{
  if (p == Pcount) return "None ";
  else if (p == Pendrep) return "Endrep ";
  else if (p >= Plaid) return "LA ";
  else if (p >= Ptablen) return tknam(tk,0);
  else return prodnampool + prodnampos[p];
}

static void printfirst(enum Nterm n)
{
  enum Token tk;
  const enum Production *pp;

  pp = prdsel + n * Stbl_tklen;
  info("%s first:",ntnam(n));
  for (tk = 0; tk < T99_count; tk++) {
    if (pp[tk] < Pendrep) info("  %s",tknam(tk,0));
  }
}

enum Sermsg {
  Ser_nil,
  Ser_nofirst,
  Ser_noexp,
  Ser_exp_tk_nomatch,
  Ser_exp_tk_nomatch1n,
  Ser_eof,
  Ser_noeof,
  Ser_eof_nostart,
  Ser_nola
};

static void ser(ub4 shfln,
  struct lexsyn *lsp,
  enum Token tk,
  ub4 fps,
  enum Nterm r,
  ub2 si,enum Sermsg sm,enum Symbol xps,ub1 ctl,
  enum Production ve)
{
  const struct sentry *ep;
  const struct seinfo *eip;
  enum Symbol s;
  const enum Symbol *sp;
  const enum Production *xep;
  enum Nterm xpr;
  enum Token mtk;
  enum Ctl z,repc;
  const enum Ctl *cp;
  enum Satrs satr=Sa_none;
  ub4 xat,i;
  ub2 atr=0;
  ub1 ns;
  ub2 se;
  ub2 si0;
  cchar *msg="";
  cchar *xpmsg="";
  char buf[1024];
  ub2 len = 1024;
  ub4 pos,pos2=0;
  enum Production xse;
  ub2 mbit,cnt;
  ub1 repsym[Scount+1];
  bool haverep = 0;

  const enum Token * restrict tks    = lsp->toks;
  const ub2        * restrict atrs   = lsp->atrs;

  switch(sm) {
    case Ser_nil: msg = "nil"; break;
    case Ser_nofirst: msg = "nofirst"; break;
    case Ser_exp_tk_nomatch: msg = "nomatch"; break;
    case Ser_exp_tk_nomatch1n: msg = "nomatch1n"; break;
    case Ser_eof: msg = "eof"; break;
    case Ser_noeof: msg = "noeof"; xpmsg = "<eof>"; break;
    case Ser_eof_nostart: msg = "eof nostart"; break;
    case Ser_noexp: msg = "noexp"; break;
    case Ser_nola: msg = "nola"; break;
  }

  xat = 0;
  pos = mysnprintf(buf,0,len,"%s: expected: %s\n",msg,xpmsg);

  printfirst(r);

  if (sm != Ser_noeof) {
    if (xps < Stoken) pos += mysnprintf(buf,pos,len,"tk.'%s'",tknam(xps,0));
    else if (xps < Smrgset) {
      xpr = xps - Stoken;
      xep = prdsel + (ub2)xpr * Stbl_tklen;
      cnt = 0;
      for (mtk = 0; mtk < T99_count; mtk++) {
        xse = xep[mtk];
        if (xse != Pcount && xse != Pendrep) {
          pos += mysnprintf(buf,pos,len,"%.*s'%s'",cnt++,",",tknam(mtk,hi32));
        }
      }
    } else {
      mbit = 1U << (xps - Smrgset);
      cnt = 0;
      for (mtk = 0; mtk < T99_count; mtk++) {
        if (tkmrgtab[mtk] & mbit) {
          if (cnt++) buf[pos++] = ',';
          pos += mysnprintf(buf,pos,len," '%s'",tknam(mtk,hi32));
        }
      }
    }
    if (ctl) pos += mysnprintf(buf,pos,len," z=%02x",ctl);
  }

  switch (ve) {
  case Pcount:  break;
  case Pendrep:   pos += mysnprintf(buf,pos,len,"end of rep at %s", tknam(tk,atr)); break;
  default: break;
  }

  if (ve < Ptablen) {
    se = vprdmap[ve] & 0xff;
    ep = syntab + se;

    sp = ep->syms;
    cp = ep->ctls;
    satr = syntabeas[se];
    ns = satr & Sa_len;
    s = sp[si];

    eip = stinfo + se;
    sinfo(fps,"si %u/%u ln %u",si,ns,eip->lno);

    pos += mysnprintf(buf,pos,len,"\n%s.%s representing '%s' at %s.%u\n",ntnam(r),prdnam(se,0),symnam(s),synfname,eip->lno);

    if (satr & Sa_s0) {
      pos += mysnprintf(buf,pos,len,"%s ",symnam(eip->s0));
    }

    memset(repsym,' ',Scount);
    si0 = 0;
    pos2 = pos;

    do {
      s = sp[si0];
      z = cp[si0];

      if (si0 == si) pos2 = pos;
      if (s < Smrgset) pos += mysnprintf(buf,pos,len,"%s%c ",symnam(s),repsym[s]);
      else pos += mysnprintf(buf,pos,len,"%s%c ",mrgnam(s - Smrgset,','),repsym[s]);
      if (repsym[s] == ' ') repsym[s] = '1';
      else { repsym[s]++; haverep = 1; }
      repc = z & Crepmask;
      if (repc == Crep01) buf[pos++] = '?';
      else if (repc == Crep0n) buf[pos++] = '*';

      if (si0 == si) {
        pos = pos2 + underline(buf + pos2,pos - pos2);
      }
      buf[pos++] = ' ';
      si0++;
    } while (--ns);
    if (haverep) pos += mysnprintf(buf,pos,len,"as %s",ntnam(r));
  }

  mysnprintf(buf,pos,len,", found '%s'\n",sm == Ser_eof ? "<eof>" : tknam(tk,atr));

  serrorfln(shfln,fps,buf,nil);
}

#ifdef Trace
  #define sdia(lsp,ti,b,s,r,lvl,se,si,fmt,...) if (dotrace) sdiafln(FLN,lsp,ti,b,s,r,lvl,se,si,fmt,__VA_ARGS__)

static void __attribute__ ((format (printf,10,11))) sdiafln(
  ub4 shfln,
  struct lexsyn *lsp,
  ub4 ti,
  ub8 bits,
  enum Symbol s,
  enum Nterm r,
  ub2 lvl,
  enum Production ve,
  ub2 si,
  cchar *fmt,...)
{
  static ub2 rowcnt;
  const enum Token * restrict tks    = lsp->toks;
  const ub2        * restrict atrs   = lsp->atrs;

  enum Token tk = tks[ti];
  ub2 lat,atr   = atrs[ti];

  ub4 fps=0,xat=0;
  ub4 len = 512;
  char buf[512];
  ub2 lno=0;
  ub2 pos,opos;

  ub4 id;
  ub2 se=0;
  enum Satrs satr=Sa_none;
  ub1 laid = 0xff;
  char c;
  cchar *pnam="";
  va_list ap;
  const struct sentry *ep=nil;
  const struct seinfo *eip=nil;

  if ( (rowcnt++ & 31) == 0) genmsgfln(0,Info,"%-19s lvl %-12s se si %-12s ti rule","","prod","sym");

  switch (ve) {
  case Pcount:  c = 'i'; break;
  case Pendrep: c = '*';  break;
  default: c = ' ';
    if (ve < Ptablen) {
      se = vprdmap[ve] & 0xff;
      ep = syntab + se; eip = stinfo + se;
      lno = eip->lno;
      satr = syntabeas[se];
      pnam = prdnam(ve,tk);
    } else if (ve >= Plaid) {
      laid = ve - Plaid;
    }
  }

  //                          lvl  prdnam    se  si symnam   ti     xat
  pos = mysnprintf(buf,0,len,"%2u %-12.11s %2u %u %-12.11s %2u %c %-10.8s %-3x",lvl,pnam,se,si,symnam(s),ti,c,ntnam(r),xat);
//  pos += mysnprintf(buf,pos,256," %02x",bits);

#ifdef Emitdetail
    opos = pos;
    pos += mysnprintf(buf,pos,len," %-4x",atr);
    lat = atr & ~ La_msk;
    atr &= La_msk;
    switch ((ub1)tk) {
    case Tid:   if (lat == La_id4) pos += mysnprintf(buf,pos,len," %lu",bits);
                break;
    case Tnlit: lat &= 0xe000;
                if (lat >= La_ilita) pos += mysnprintf(buf,pos,len," %.7s",lsp->src + bits);
                else if (lat >= La_ilit4) pos += mysnprintf(buf,pos,len," %lu",bits);
                else pos += mysnprintf(buf,pos,len,"%u",atr);
                break;
    case Tslit: id = hi32;
                if (lat == La_slits) id = atr;
                else if (lat == La_slit) id = bits;
                else if (lat == 0) buf[pos++] = atr;
                if (id != hi32) pos += mysnprintf(buf,pos,len," %s",chprints(lsp->slitpool + id,6));
                break;
    default:    break;
    }
    while(pos < opos + 8) buf[pos++] = ' ';
#endif

  buf[pos++] = laid != 0xff ? '?' : ' ';
  buf[pos++] = (satr & Sa_rep) ? '*' : ' ';

  // pos += mysnprintf(buf,pos,len,"%3u ",lno);

#if 0
  if (ep) {
    sp = ep->syms;
    if (si) pos += mysnprintf(buf,pos,len,"%-10.8s ",symnam(sp[si-1]));
    pos += mysnprintf(buf,pos,len,"%-10.8s ",symnam(sp[si]));
  }
#endif

  while (pos < 50) buf[pos++] = ' ';
  buf[pos] = 0;

  ub4 fpx = fps | (ub4)(Msg_shcoord | Msg_lno | Msg_col | Msg_Lvl | 0x80 ) << 24;

  va_start(ap,fmt);

  vmsgps(shfln,Info,fpx,fmt,ap,buf,nil);

  va_end(ap);
}
#else
  #define sdia(lsp,ti,b,s,r,lvl,se,si,fmt,...)
#endif

int syn(struct lexsyn *lsp,struct synast *sa,ub8 T0)
{
  ub8 T1 = T0;
  timeit(&T1,nil);

  ub4 t1 = T1 / 1000;

  cchar *name = lsp->name;

  const enum Token * restrict tks = lsp->toks;
  const ub2 * restrict atrs   = lsp->atrs;
  const ub8 * restrict tkbits = lsp->bits;
  const ub1 * restrict dfp0s  = lsp->dfp0s;

  int rv = 0;

  ub4 tcnt = lsp->tkcnt;
  ub4 bcnt = lsp->tbcnt;

  ub4 ti = 0; // token index
  ub4 bi = 0;

  ub2 lvl = 0,hilvl = 0;

  // main parser stack
  ub1 ves[Depth]; // ve
  ub1 sis[Depth]; // si
  ub4 ids[Depth]; // ast gid
  ub4 reporg[Depth];
  ub4 reppos[Depth];
  ub4 repcnts[Depth];

  ub2 scid = 0;

  // repetitions
  ub4 repcnt=0,crepcnt=0,repncnt,repnpos1=0,pos,hirep=0;
  ub8 repid;

  ub4 fps=0,hirepfps=0,fpx=0,xat;
  ub4 fn0=0,fn1=0;
  ub1 dfp0;
  ub4 dfp;
  ub8 bits = 0;
  ub4 idid = 0;

  ub1 si = 0,len;
  ub2 nxndx;
  ub2 mrg;
  Mrgbits mrgbit;

  ub1 match=0;

  enum Token tk=0,rtk,tk1;
  ub2 atr,lat;
  const enum Symbol *sp=nil;
  enum Symbol s=0;
  enum Ctl z,repc,repcc,arg,doleaf;
  enum Nterm nxr=0,r=startrule;
  ub2 se=0,x2;
  ub4 ndti=0;
  enum Production ve,nxve;
  ub2 ai,argc,isrep,mknod;
  const enum Ctl *cp=nil;

#ifdef Lacnt
  ub1 laid;
  ub1 lasn,lan;
  ub2 lasi;
  ub8 tkbit;
  lasec_t sec;
  const lasec_t *lasp;
#endif

  const struct sentry *ep=nil;

  ub4 uidcnt = lsp->uidcnt;

  ub4 *ndcnts = sa->ndcnts;
  ub4 *rep2cnts = sa->rep2cnts;

  ub4 slithilen = lsp->slithilen;
  const ub1 *slitpool = lsp->slitpool;

  ub2 uid1cnt = lsp->uid1cnt;
  ub2 uid2cnt = lsp->uid2cnt;
  ub4 idcnt = lsp->idcnt;

  sa->uidcnt = uidcnt + uid1cnt + uid2cnt;

  ub4 nvcnt = idcnt + lsp->nlitcnt + lsp->slitcnt;

  sa->idcnt = idcnt + lsp->id1cnt + lsp->id2cnt;

  info("hiruldep %u vals %u",hiruldep,nvcnt);

  ub4 aid=0,pid,ppid,pidlvl,cid=0,aidcnt;
  ub4 startnd = hi32;
  enum Astyp aty=0;

  ub4 cnt;
  ub4 apos,acnt=0,vpos,vcnt=0;

  ub4 itercnt = 0,iterlim = tcnt * 8;

  memset(sis,0xff,Depth); // mark max depth

#ifdef Lacnt
  enum Production *lave = alloc_fln(FLN,tcnt,1,Mnofil,"syn lave",nextcnt);
#endif

  info("parsing %u`  tokens",tcnt);

  // -- pass 1 --

  info("+syn1 %u",gettime_msec()-t1);

  si = 0;

  ve = startve;

  repcnts[0] = 0;
  sis[0] = 0;
  ves[0] = ve;
  lvl = 1;

// -------------------
rulstart1:
// -------------------

// select production
  ai = syntabeas[ve];
  argc = (ai & Sa_arg) >> 8; // todo unused

  sdia(lsp,ti,0,s,r,lvl,ve,si,"pos %u select ai %x",fps,ai);

  if (ai & Sa_s0) {
    ti++;
  }
  se = vprdmap[ve] & 0xff;

  ep = syntab + se;
  sp = ep->syms;

  cp = ep->ctls;
  arg = cp[0] & Cargmask;

  sdia(lsp,ti,0,*sp,r,lvl,ve,si,"se '%s' len %u",stinfo[se].src,ai & 0xf);

// --- match production
  si = (ai & Sa_si) >> 4;

  isrep = ai & Sa_rep;

  if (isrep) {
    repcnts[lvl] = 0;
  }

// -------------------
nxtrep1:
// -------------------

  if (ai & Sa_nod) aid++;

// -------------------
nxtsym1:
// -------------------

  len = ai & 0xf;

  do { // each sym in clause

    // info("reppm %u isrep %u",reppm,isrep);

    if (si >= Slen) ice(0,fps,"si %u",si);
    if (++itercnt > iterlim) ice(0,fps,"iter lim %u",iterlim);

    rtk  = tks[ti];

    if (rtk & 0x80) {
      tk = rtk & 0x3f;
      dfp0 = dfp0s[fn0++];
      dfp = dfp0 & 0x7f;
      if (dfp0 & 0x80) {
        dfp |= dfp0s[fn0++] << 7;
        dfp |= dfp0s[fn0++] << 15;
      }
      fps += dfp;
    } else {
      tk = rtk;
    }

    s = sp[si];
    z = cp[si];

    repc = z & Crepmask;
    arg  = z & Cargmask; // 1-based

    sdia(lsp,ti,0,s,r,lvl,ve,si,"z %x",z);
    match = 1;

    if (s >= Stoken && s < Smrgset) { // nonterms -> push

      nxr = s - Stoken;
      nxndx = nxr * Stbl_tklen + tk;
      nxve = prdsel[nxndx];
      // sinfo(fps,"r %u ndx %u ve %u",nxr,nxndx,nxve);

#ifdef Lacnt
      if (nxve >= Plaid && nxve < Pendrep) { // lookahead
        laid = nxve - Plaid;
        lan = lasetn[laid];
        tk1 = tks[ti+1];
        tkbit = 1UL << tk1;

        lasi = lasecmap[laid * T99_count + tk];
        if (lasi != 255) {
          lasp = laseclst + lasi * Laset;
          for (lasn = 0; lasn < lan; lasn++) {
            sec = lasp[lasn];
            if (sec & tkbit) break;
          }
          sdia(lsp,ti,0,s,r,lvl,nxve,si,"laid %u %lx %u/%u",laid,tkbit,lasn,lan);
          if (lasn < lan) {
            sdia(lsp,ti,0,s,r,lvl,nxve,si,"la %u on tk %s",lasn,tknam(tk1,0));
            nxve = lasets[laid * Laset + lasn];
            lave[ti] = nxve;
          } else if (ti >= tcnt) { info("eof at %u",ti); goto endsym1; }
            else ser(FLN,lsp,tk,fps,nxr,si,Ser_nofirst,T99_count,z,se);
        } else ser(FLN,lsp,tk,fps,nxr,si,Ser_nofirst,T99_count,z,se);
      } // la
#endif

      if (nxve < Ptablen) { // regular match -> push into new rule

        sdia(lsp,ti,0,s,r,lvl,nxve,si,"push %u into rule %s ve %u from prd %s",ve,ntnam(nxr),nxve,prdnam(ve,tk));

        if (lvl + Skip >= Depth) ice(fps,0,"exceeding %u nesting depth",lvl);

        sis[lvl] = si; // (repc == Crep0n ? si : si + 1);
        ves[lvl] = ve;
        lvl++;

        ve = nxve;

        r = nxr;
        si = 0;

        goto rulstart1;

      } else if (nxve < Plaid) { // direct match -> nonterm
        sdia(lsp,ti,0,s,r,lvl,nxve,si,"direct match, node %2u",aid);

      } else if (nxve == Pendrep) { // rep of none
        match = 0;
        sdia(lsp,ti,0,s,r,lvl,nxve,si,"rep of none %u",nxr);
        si++;

      } else { // nonmatch nterm
        match = 0;
        sdia(lsp,ti,0,s,r,lvl,nxve,si,"no match repc %x",repc);
      }

    } else {
      nxve = ve;
      if (s < Stoken) { // token = term
        match = (s == (enum Symbol)tk);

      } else if (s < Scount) { // merged tokens
        mrg = s - Smrgset;
        mrgbit = 1U << mrg;
        match = (tkmrgtab[tk] & mrgbit);
        // if (match) info("match set %u tk %s",mrg,tknam(tk,0));
        // else info("nonmatch set %u bit %x.%x tk %s",mrg,mrgbit,tkmrgtab[tk],tknam(tk,0));
      }

      if (match) {
        sdia(lsp,ti,0,s,r,lvl,ve,si,"match term %u len %u",z,len);

      } else { // nonmatch term

//        info("tk %u.%s ti %u s %u.%s si %u/%u",tk,tknam(tk,0),ti,s,symnam(s),si,len);
        sdia(lsp,ti,0,s,r,lvl,se,si,"nonmatch term '%s' z %x repc %x",tknam(tk,0),z,repc);

      } // nonmatch

    } // term

    if (match) {
      ti++;

      if (arg) {
        acnt++;
        vcnt++;
        aid++;
      }

      if (repc == Creplp) {
        goto endsym1; // continue rep
      } else if (repc != Crep0n) si++;

    } else {
      if (repc == Crep01 || repc == Crep0n) si++; // common case
      else if (repc == Creplp) goto endsym1; // end rep
      else {
        repcc = repc >> Crepshift;
        if (repcc) {
          sdia(lsp,ti,0,s,r,lvl,nxve,si,"skip grp %u",repcc);
          si += repcc;
        } else if (ti >= tcnt) { info("eof at %u",ti); goto endsym1; }
        else ser(FLN,lsp,tk,fps,nxr,si,Ser_nofirst,T99_count,z,se);
      }
        // info("ti %u",ti);
    }
//    info("si %u/%u",si,len);
  } while (si < len); // each sym in clause

// ------------
endsym1:
// ------------

  if (isrep) { // repeat rule
    repcnt = repcnts[lvl];

    // sinfo(fps,"repcnt %u at lvl %u",repcnt,lvl);
    repcnts[lvl] = repcnt + 1;

    if (match && ti < tcnt) {
      si = 0;
      goto nxtrep1;

    } else { // nonmatch at end of rep -> ok end

      sdia(lsp,ti,0,s,r,lvl,ve,si,"end rep on %u tk %s %u",se,tknam(tk,0),ve);
      crepcnt += repcnt + 1;
      if (repcnt) {
        aid++;
        acnt++;
        vcnt++;
      }
    }
  } else {
    // sinfo(fps,"isrep %u",isrep);
  }

  if (ti >= tcnt) goto eof1;

  else if (lvl == 0) ice(hi32,fps,"pop at lvl 0 after %u/%u tokens and %u` nodes",ti,tcnt,aid);

  // pop. note: si not moved at push
  lvl--;

  si = sis[lvl];
  nxve = ves[lvl];

  // info("node %u nxve %u",ni,nxve);

  ai = syntabeas[nxve];

  x2 = vprdmap[nxve];

  sdia(lsp,ti,0,s,r,lvl,se,si,"pop into rule %s prd %s %u",ntnam(x2 >> 8),prdnam(nxve,tk),x2 & 0xff);

  se = x2 & 0xff;
  r = x2 >> 8;

  ep = syntab + se;
  sp = ep->syms;

  cp = ep->ctls;

  len = ai & 0xf;

  z = cp[si];
  repc = z & Crepmask;
  arg  = z & Cargmask;

  isrep = ai & Sa_rep;
  mknod = ai & Sa_nod;

  if (mknod && arg && isrep == 0) {
    acnt++;
  }

  ve = nxve;

  if (repc == Crep11 || repc == Crep01) {
    si++;
  }

//  info("se %u si %u s %u",se,si,sp[si]);

  if (si >= len) goto endsym1;
  else {
    goto nxtsym1;
  }

// ---
  eof1:
// ---

  info("-syn1 %u",gettime_msec()-t1);

  info("ti %u/%u",ti,tcnt);
  showcnt("3node",aid);
  showcnt("3arg",acnt);
  showcnt("3val",vcnt);
  showcnt("3repitem",crepcnt);

  if (ti < tcnt) {
    info("ti %u/%u",ti,tcnt);
    ser(FLN,lsp,tk,fps,r,si,Ser_eof_nostart,T99_count,0,0);
    return 1;
  }

  if (aid == 0) {
    info("nil nodes for %u tokens",tcnt);
    return 0;
  } else if (aid >= Argmsk) fatal(0,hi32,"AST node count %u` exceeds max %u`",aid,Argmsk);

  aidcnt = aid;
  apos = vpos = 0;

  aid = 0;
  pid = 0;

  hilvl = 0;
  while (hilvl < Depth && sis[hilvl] != 0xff) hilvl++;

  info("max parser stack lvl %u",hilvl);
  if (lvl > 1) ice(hi32,fps,"syn eof at lvl %u",lvl);

//  if (r != startrule) { ser(FLN,tk,bits,fps,ti,r,si,Ser_eof_nostart,T99_count,0,0); return 1; }

  if (globs.rununtil < 4) { info("until %u",globs.rununtil); return 1; }

  ti = 0;
  si = 0;

  ve = startve;

  repcnts[0] = 0;
  sis[0] = 0;
  ids[0] = 0;
  ves[0] = ve;
  lvl = 1;

  // -- pass 2 --

  info("+syn2 %u",gettime_msec()-t1);

  ub2 *nlnos = alloc(aidcnt+1,ub2,Mnofil,"syn lnos",nextcnt); // dbg

  ub4 *nhs   = alloc(aidcnt+1,ub4,Mnofil,"syn nhs",nextcnt);
  ub4 *nfps  = alloc(aidcnt+1,ub4,Mnofil,"syn fps",nextcnt);

  ub8 *nargs = alloc(acnt+1,ub8,Mnofil,"syn nargs",nextcnt);

  ub8 *nvals = alloc(vcnt,ub8,Mnofil | Mo_ok0,"syn nvals",nextcnt);
  sa->vals = nvals;

  ub4 repos = 0;
  ub8 *repool = alloc(crepcnt,ub8,Mnofil | Mo_ok0,"syn repool",nextcnt);

  info("parsing %u`  tokens",tcnt);

// -------------------
rulstart:
// -------------------

// select production
  ai = syntabeas[ve];
  argc = ai >> 8;

  if (ai & Sa_s0) {
    ti++;
  }
  se = vprdmap[ve] & 0xff;

  ep = syntab + se;
  sp = ep->syms;

  cp = ep->ctls;
  arg = cp[0] & Cargmask;

// --- match production
  si = (ai >> 4) & 3;
  isrep = ai & Sa_rep;
  mknod = ai & Sa_nod;

  if (isrep) {
    repcnts[lvl] = 0;
  }

// -------------------
nxtrep:
// -------------------

  if (mknod) {
    pid = aid++;
    fps = 0; // todo
    aty = prd2nod[ve];
    ndti = ndcnts[aty]++;
    nhs[pid] = ndti | (aty << Atybit);
    nfps[pid] = fps;
    nlnos[pid] = __LINE__;
    Sinfo(fps,"ai %x isrep %u arg %x Pid %u.%u ve %u %s %s",ai,isrep,arg,pid,ndti,ve,prdnam(ve,tk),atynam(aty));
  } else {
    aty = nhs[pid] >> Atybit;
    svrb(fps,"lvl %u ai %x isrep %u arg %x pid %u %s ti %u %s",lvl,ai,isrep,arg,pid,atynam(aty),ti,tknam(tks[ti],0));
  }
  cid = pid;

// -------------------
nxtsym:
// -------------------

  len = ai & 0xf;
  argc = ai >> 8;
  isrep = ai & Sa_rep;

  aty = nhs[pid] >> Atybit;
  // sinfo(fps,"lvl %u ai %x isrep %u arg %x pid %u %s ti %u %s",lvl,ai,isrep,arg,pid,atynam(aty),ti,tknam(tks[ti],0));

  do { // each sym in clause

    tk = tks[ti];

    s = sp[si];
    z = cp[si];

    repc = z & Crepmask;
    arg  = z & Cargmask; // 1-based

    match = 1; // common, tentative
    doleaf = 0;
    if (s >= Stoken && s < Smrgset) { // nonterms -> push

      nxr = s - Stoken;
      nxndx = nxr * Stbl_tklen + tk;
      nxve = prdsel[nxndx];

#ifdef Lacnt
      if (nxve >= Plaid && nxve < Pendrep) { // lookahead
        if (ti >= tcnt) { info("eof at %u",ti); goto endsym; }
        else nxve = lave[ti];
      } // la
#endif

      if (nxve < Ptablen) { // regular match -> push into new rule

        sis[lvl] = si; // (repc == Crep0n ? si : si + 1);
        ves[lvl] = ve;
        ids[lvl] = pid;
        lvl++;

        ve = nxve;
        sdia(lsp,ti,0,s,nxr,lvl,se,si,"push into ve %s from %s",prdnam(ve,tk),ntnam(r));

        r = nxr;
        info("pid %u cid %u aid %u",pid,cid,aid);
        pid = cid;
        goto rulstart;

      } else if (nxve < Plaid) { // direct match -> nonterm
        doleaf = arg; // unconditional ?

      } else if (nxve == Pendrep) { // rep of none
        match = 0;
        si++;

      } else { // nonmatch nterm
        match = 0;
      }

    } else { // terms
      if (s < Stoken) { // token = term
        match = (s == (enum Symbol)tk);

      } else if (s < Scount) { // merged tokens
        mrg = s - Smrgset;
        mrgbit = 1U << mrg;
        match = (tkmrgtab[tk] & mrgbit);
      }

      if (match) {
        doleaf = arg; // unconditional ?
      } // nonmatch

    } // term

    if (doleaf) {

      atr = atrs[ti];

      lat = atr & ~ La_msk; atr &= La_msk;
      switch (tk) {

      case Tid:
        // blt - dun - id1 - id2 id
        lat &= 0xe000;
        if (lat == La_idblt) {
          switch (atr) {
//              case BTrue:  aty = Atru; break;
//              case BFalse: aty = Afal; break;
          default:     aty = Aid;
          }
          if (aty != Aid) {
            ndti = 0;
            break;
          }
          idid = atr;
        } else if (lat == La_iddun) {
          idid = atr + B99_count;
        } else {
          switch (lat) {
          case 0:      idid = atr + uid1cnt + uid2cnt; break;
          case La_id1: idid = atr; break;
          case La_id2: idid = atr + uid1cnt; break;
          case La_id4: idid = tkbits[bi++]; break;
          default: ice(0,fps,"invalid Id atr %x",lat);
          }
          idid += B99_count + D99_count;
        }
        aty = Aid; arg |= Nodval;
        ndti = ndcnts[aty]++;
        if (aid < 10) svrb(fps,"id aid %u.%u pid %u apos %u vpos %u id %u",aid,ndti,pid,apos,vpos,idid);
        nvals[vpos++] = idid;
      break;

      case Tnlit:
        switch (lat & 0xe000) {
        case 0: ndti = atr; aty = Ailits; break;
        case La_ilit4:
          bits = tkbits[bi++];
          if (bits < Atybit) { aty = Ailits; ndti = bits; }
          else aty = Ailit;
          break;
        case La_flit8: fatal(0,fps,"flt lits %x todo",atr);
        case La_ilita:
        case La_flita: sinfo(fps,"ascii lits %u todo",atr);
                       bits = tkbits[bi++];
                       break;
        default: ice(0,0,"invalid nits atr %x",atr);
        }
        cnt = ndcnts[aty]++;
        if (aty != Ailits) {
          ndti = cnt; arg |= Nodval;
          nvals[vpos++] = bits;
        }
      break;

      case Tslit:
        if (lat == La_slit) {
          aty = Aslit; arg |= Nodval;
          ndti = ndcnts[aty]++;
          bits = tkbits[bi++];
          // info("id aid %u.%u pid %u apos %u vpos %u",aid,ndti,pid,apos,vpos);
          nvals[vpos++] = bits;
        } else {
          aty = Aslits;
          ndcnts[aty]++;
          switch (lat) {
          case 0:        ndti = atr | (1U << Atrbit); break; // 1
          case La_slit0: ndti = 0; break; // 0
          case La_slit2: ndti = tkbits[bi++] | (2U << Atrbit); break;
          case La_slit3: ndti = tkbits[bi++] | (3U << Atrbit); break;
          case La_slits: ndti = atr | (7U << Atrbit); break; // short id
          case La_slit:   break; // id
          }
        }
//            info("lat %x t %u",lat,aty);
      break;

      case Top: aty = Aop;
                ndcnts[aty]++;
                ndti = atr;
                // sinfo(fps,"op %u %u",ndcnts[aty],atr);
      break;

      case Taas: aty = Aop;
                 ndcnts[aty]++;
                 ndti = atr; // dbg
      break;

      case Tdas: aty = Aop;
                 ndcnts[aty]++;
                 ndti = 0xff; // dbg
      break;

      default:  ice(fps,0,"unhandled token type %s",tknam(tk,0));
                // aty = Acount; ndcnts[aty]++; break; // todo rep
      }

      if (ndti >= Atymsk && (arg & Nodval) ) serror(fps,"node count exceeds limit %u",Atymsk);
      nhs[aid] = ndti | (aty << Atybit);
      nfps[aid] = fpx;
      if (aty != Acount && mknod == 0) pid = aid;
      pidlvl = pid | (lvl << Argbit);
      sinfo(fps,"apos %u arg %u pid %u lvl %u nd %u.%u t %s %s",apos,arg,pid,lvl,aid,ndti,atynam(aty),atynam(nhs[pid] >> Atybit));
      nargs[apos++] = aid | ((ub4)arg << Argbit) | ((ub8)pidlvl << 32);
      nlnos[aid] = __LINE__;
      aid++;
      // info("arg %u %x ve %u si %u",argc,argp[argc],ve,si);
    } // doleaf

    info("lvl %u si %u pid %u",lvl,si,pid);

    if (match) {
      ti++;
      if (repc == Creplp) {
        if (ti >= tcnt) match = 0;
        goto endsym; // continue rep
      } else if (repc != Crep0n) si++;
    } else {
      if (repc == Crep01 || repc == Crep0n) si++; // common case
      else {
        repcc = repc >> Crepshift;
        if (repcc) {
          si += repcc;
        } else if (ti >= tcnt) { info("eof at %u",ti); goto endsym; }
      }
    }
  } while (si < len); // each sym in clause

// ------------
endsym:
// ------------

  // info("lvl %u si %u pid %u",lvl,si,pid);

  if (isrep) { // repeat rule
    repcnt = repcnts[lvl];
    info("lvl %u repcnt %u match %u",lvl,repcnt,match);

    if (repcnt | match) {
      if (repcnt == 0) {
        pos = reporg[lvl] = repos;
      } else {
        pos = reppos[lvl];
        repool[pos] |= ((ub8)repos << 32); // link from previous
      }
      reppos[lvl] = repos;
      if (repos >= crepcnt) ice(fps,0,"repos %u above %u",repos,crepcnt);
      repid = pid;
      aty = nhs[pid] >> Atybit;
      sinfo(fps,"rep pos %u-%u at lvl %u pid %u %s",repcnt,repos,lvl,pid,atynam(aty));
      repool[repos++] = repid;
      repcnts[lvl] = repcnt + 1;

      if (match) {
        si = 0;
        goto nxtrep;

      } else { // nonmatch at end of rep -> ok end
        sdia(lsp,ti,0,s,r,lvl,ve,si,"end rep on %u tk %s %u",se,tknam(tk,0),ve);

        // create rep node
        pos = reppos[lvl];
        repool[pos] = pid;

        pos = reporg[lvl];
        pid = aid;
        aty = Prd2nod[ve];
        if (repcnt == 2) rep2cnts[aty]++;
        ndti = ndcnts[aty]++;
        Sinfo(fps,"rep node %u ap %u vp %u cnt %u ve %u.%u %s %s",pid,apos,vpos,repcnt+1,ve,aty,prdnam(ve,0),atynam(aty));
        nlnos[aid] = __LINE__;
        nhs[aid++] = ndti | (aty << Atybit);

        nargs[apos++] = pid | ((ub8)pos << 32);
        nvals[vpos++] = (repcnt+1) | ((ub8)lvl << 32);
      }
    } else if (ve == startve) startnd = pid;
  }

  if (ti >= tcnt) { info("eof at %u",ti); goto eof; }
  else if (lvl <= 1) ice(hi32,fps,"pop at lvl 0 after %u/%u tokens and %u` nodes",ti,tcnt,aid);

  cid = pid;

  // pop. note: si not moved at push
  lvl--;

  si   = sis[lvl];
  nxve = ves[lvl];

  ai = syntabeas[nxve];
  mknod = ai & Sa_nod;
  isrep = ai & Sa_rep;

  x2 = vprdmap[nxve];

  se = x2 & 0xff;
  r = x2 >> 8;

  ep = syntab + se;
  sp = ep->syms;

  cp = ep->ctls;

  len = ai & 0xf;

  z = cp[si];
  repc = z & Crepmask;
  arg  = z & Cargmask;

  sdia(lsp,ti,0,s,r,lvl,se,si,"pop into %s rule %s prd %s si %u/%u %u",ntnam(x2 >> 8),isrep ? "rep" : "",prdnam(nxve,tk),si,len,x2 & 0xff);

  if (mknod) {
    pid  = ids[lvl];
    if (arg && isrep == 0) {
      svrb(fps,"lvl %u apos %3u vp %u cid %u.%u pid %u.%u %-6s %-6s",lvl,apos,vpos,cid,nhs[cid] & Atymsk,pid,nhs[pid] & Atymsk,atynam(nhs[cid] >> Atybit),atynam(nhs[pid] >> Atybit));
      pidlvl = pid | (lvl << Argbit);
      nargs[apos++] = cid | ((ub4)arg << Argbit) | ((ub8)pidlvl << 32);
    }
  }

  ve = nxve;

  if (repc == Crep11 || repc == Crep01) {
    si++;
  }

//  info("se %u si %u s %u",se,si,sp[si]);

  if (si >= len) goto endsym;
  else {
    goto nxtsym;
  }

// ---
  eof:
// ---

  info("-syn2 %u",gettime_msec()-t1);

  info("ti %u/%u bits %u/%u",ti,tcnt,bi,bcnt);
  showcnt("3node",aid);
  showcnt("3arg",apos);
  showcnt("3val",vpos);
  showcnt("3rep",repos);

  if (apos < acnt) warning("node args %u vs %u dif %u",apos,acnt,acnt - apos);
  else if (apos > acnt) ice(0,0,"node args %u vs %u",apos,acnt);
  nargs[apos] = hi64;

  if (vpos < vcnt) info("node vals %u vs %u dif %u",vpos,vcnt,vcnt - vpos);
  else if (vpos > vcnt) ice(0,0,"node vals %u vs %u",vpos,vcnt);

#ifdef Lacnt
  afree(lave,"syn lave",nextcnt);
#endif

  if (ti < tcnt) {
    info("ti %u/%u",ti,tcnt);
    ser(FLN,lsp,tk,fps,r,si,Ser_eof_nostart,T99_count,0,0);
    return 1;
  }

  if (aid == 0) {
    info("nil nodes for %u tokens",tcnt);
    return 0;
  }

  if (aid < aidcnt) warning("aid %u vs %u dif %u",aid,aidcnt,aidcnt - aid);
  else if (aid > aidcnt) ice(0,fps,"aid %u vs %u",aid,aidcnt);

  cnt=0;
  for (aty = 0; aty <= Acount; aty++) {
    cnt = ndcnts[aty];
    showscnt(6,atynam(aty),cnt);
  }
  if (cnt) ice(0,0,"%u invalid nodes",cnt);

  if (startnd == hi32) startnd = aid-1;

  nfps[aid] = fps;
  nhs[aid++] = Acount << Atybit; // eof
  ndcnts[Acount] = 1;
  aidcnt = aid;

  acnt = apos;
  vcnt = vpos;

  if (lvl > 1) ice(hi32,fps,"syn eof at lvl %u",lvl);

//  if (r != startrule) { ser(FLN,tk,bits,fps,ti,r,si,Ser_eof_nostart,T99_count,0,0); return 1; }

  bool emit = globs.emit & 2;
  ub4 nn,x4;
  ub8 x8;

  if (emit) {
    if (name) msglog(name,"nds","syn");

    for (aid = 0; aid < aidcnt; aid++) {
      nn = nhs[aid];
      ndti = nn & Atymsk;
      aty = nn >> Atybit;
      fpx = nfps[aid];
      fps = fpx & Lxamsk;
      sinfo(fps,"nd %-4u  t %-8s ni %-4u ln %3u",aid,atynam(aty),ndti,nlnos[aid]);
    }
    for (apos = 0; apos < acnt; apos++) {
      x8 = nargs[apos];
      x4 = x8;
      pidlvl = x8 >> 32;
      pid = pidlvl & Argmsk;
      lvl = pidlvl >> Argbit;
      cid = x4 & Argmsk;
      arg = x4 >> Argbit;
      info("arg %4u cid %4u pid %4u ac %x lvl %u",apos,cid,pid,arg,lvl);
    }
    for (cnt = 0; cnt < repos; cnt++) {
      repid = repool[cnt];
      cid = repid & hi32;
      pos = repid >> 32;
      info("rep %u %u",cid,pos);
    }
    msglog(nil,nil,"syn");
  }

  afree(lsp->tkbas,"lex tokens",nextcnt);

  if (globs.rununtil < 4) {
    info("until %u %u",globs.rununtil,gettime_msec()-t1);
    return 1;
  }

  sa->name = name;
  sa->nhs = nhs;
  sa->fps = nfps;
  sa->aidcnt = aidcnt;
  sa->args = nargs;
  sa->argcnt = acnt;
  sa->valcnt = vcnt;
  sa->nlnos = nlnos; // dbg

  sa->slitpool = slitpool;
  sa->slithilen = slithilen;

  sa->nscid = scid;
  sa->repcnt = crepcnt;
  sa->repool = repool;
  sa->startnd = startnd;

  return rv;
}

cchar *syn_info(void) { return syninfo; }

int inisyn(void)
{
  ub4 i;
  enum Production prd;
  cchar *trc;

  sassert(sizeof(enum Token) == 1,"expected 8 bits tokens");
  sassert(sizeof(enum Production) == 1,"expected 8 bits productions");

  // sassert(Tkpad > Syn_maxlen,"token padding accomodates max production len");

  ub4 slen = (ub4)sizeof(struct sentry);
  ub4 ilen = (ub4)sizeof(struct seinfo);
  ub4 len = poolsizes;

  if (globs.resusg) {
    info("pool %u`B",poolsizes);
    info("stab1 %3u * %2u = %3u`B",Ptablen,slen,(ub4)sizeof(syntab));
    info("stab2 %3u * %2u = %3u`B",Ptablen,ilen,(ub4)sizeof(stinfo));

#ifdef Lacnt
    info("la tab %u`B",Latabsizes);
    len += Latabsizes;
#endif
    len += sizeof(syntab);
    len += sizeof(stinfo);

    info("stpos %3u * %2u = %3u`B",Ncount,Stbl_tklen,(ub4)sizeof(prdsel));

    len += sizeof(prdsel);

    info("total          = %3u`B",len);
  }
  for (i = 0; i < Ncount * T99_count; i++) {
    prd = prdsel[i];
    if (prd > Pcount) ice(0,hi32,"invalid symbol table entry %u at %u.%u",prd,i / T99_count,i % T99_count);
  }

#ifdef Lacnt
  info("productions with lookahead: %u",Lacnt);
#endif

  if (globs.trace & Synpas) dotrace = 1;

#ifdef Trace
  trc = "en";
#else
  dotrace = 0;
  trc = "dis";
#endif
  info("tracing: %sabled, %s",trc,dotrace ? "on" : "off");

  char *ap = prodnampool;
  ub2 t=0;
  ub2 pos=0;

  while (ap[pos] && t <= Pcount) {
    if (ap[pos] == ' ') {
      ap[pos] = 0; t++;
    }
    pos++;
  }

  lastcnt

  return 0;
}
