/* gensyn.c - generate LL parser tables from grammar

   This file is part of Luanova, a fresh implementation of Lua.

   Copyright Â© 2022 Joris van der Geer.

   Luanova is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Luanova is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU Affero General Public License
   along with this program, typically in the file License.txt
   If not, see http://www.gnu.org/licenses.
 */

/* Gensyn reads token definitions as generated by genlex and a grammar
   The grammar consists of rules, each rule containing a list of possible productions
   A production describes the sequence of symbols to match
   A tag after a production names the parser node to produce.
   Output is a set of tables for the parser syn to use.
   These tables guide a predictive top-down aka LL parser.
   1 token of lookahead is always needed, two tokens in case of ambiguity.
   In the latter case, an additional disambiguating table is generated.
   The size of the tables is approx <rule count> * <number of unique tokens>,
   plus the total number of symbols in the grammar.

--- + snip ---

   statement
     Def Id ( paramlst ) : block `funcdef
     While expr : block ?( Else : block ?) `while_statement

--- - snip ---

  means : a statement consists of either a funcdef or while_statement
      A funcdef is the sequence :
      keyword 'def'
      identifier
      '('
      parameter list as non-terminal aka subrule- not shown here -
      ')'
      ':'
      code block - not shown here

      ?( ... ?) means optional, can either be present fully or not at all
      Id? means 0 or 1 times Id
      Id* means 0 or n times Id
      (Nlit | Slit) means either Nlit or Slit

      Storable terminals such as literals and identifiers are automatically added as node args

      As an alternative to left recursion, a rule marked with asterix generates a list of items,
      terminating at the absence of the last symbol marked with '+'

--- + snip ---

     *paramlist
       param +,

--- - snip ---

    This generates a list of <param> nodes, one for each param separated by a comma and returning after the last param without a comma

 */

#include <stdarg.h>
#include <string.h>

#include "../base.h"

#include "../chr.h"

#include "../fmt.h"

#include "../mem.h"
#include "../os.h"

#include "../tim.h"

static ub4 msgfile = Shsrc_gensyn;
#include "../msg.h"

#include "../util.h"

// generated by genlex
#include "../tok.h"

#define Gensyn

#include "../syn.h"

#if defined __clang__
 #pragma clang diagnostic ignored "-Wsign-conversion"
 #pragma clang diagnostic ignored "-Wswitch-enum"
#elif defined __GNUC__
 #pragma GCC diagnostic ignored "-Wsign-conversion"
 #pragma GCC diagnostic ignored "-Wpointer-sign"
#endif

static const char version[] = "0.1.0-alpha";

static const char packed8[] = "Packed8 ";

static const char *specname; // arg 1
static const char *stabname; // arg 2
static const char *sdefname; // arg 3

static bool allowunref = 0;

static bool ena_lookahead = 1;
static bool ena_benambi = 0;
static ub2 lareqs;

static bool hastidctl,enatidctl = 0;
static bool do_transcript = 0;

struct globs globs;

static ub2 msgopts = Msg_shcoord | Msg_fno | Msg_lno | Msg_col | Msg_Lvl;

#define Nnterm 32
#define Nsym (Nnterm + T99_count)
#define Nalt 16
#define Nsi 4
#define Altlen 16

#define Dsclen 64

#define Ntnam 32

struct rule {
  ub1 id;
  ub1 ref;
  ub1 altcnt;
  ub1 maxlen;
  ub1 lotcnt,hitcnt,hisi;
  ub1 rulrep;
  ub1 hidep;
  bool havearg;
  ub1 mrgset;
  ub1 argcnt;

  ub2 lno;

  ub8 secadd;

  char name[Ntnam];

  ub4 first[Nsi * T99_count]; // bit=alt dim0=term1 dim1=si
  ub4 tfirst[Nsi * T99_count];
  ub4 rfirst[Nsi * T99_count];

  ub4 first0[T99_count]; // bit=alt
  ub4 tfirst0[T99_count];
  ub4 rfirst0[T99_count];

  ub2 firstra[T99_count]; // alt | r
  ub1 firstrn[T99_count];
  ub1 firstrc[T99_count];

  ub8 secr[T99_count];

  ub8 second0[T99_count]; // bit=tkterm2 dim0=term1
  ub8 second[Nalt * Nsi * T99_count]; // bit=tkterm2 dim0=term1 dim1=si dim2=alt

  ub1 altlens[Nalt];
  ub2 lnos[Nalt];

  ub2 prdid[Nalt];

  ub1 ltis[Nalt];
  ub1 hisis[Nalt];

  ub1 dolas[Nalt];

  ub1 desc[Nalt * Dsclen];
  ub2 dsclen[Nalt];

  cchar *prdnam[Nalt];
  ub1 prdnlen[Nalt];

  ub1 argcnts[Nalt];

  ub1 alts[Nalt * Altlen];
  ub1 ctls[Nalt * Altlen];
  ub1 args[Nalt * Altlen];
};

static struct rule rules[Nnterm];
// static ub2 rulpri[Nnterm];
// static ub1 *rulord;
// static ub4 hipri2;
static ub1 startrule,startrnlen;
static ub1 startve;

#define Spool 4096

#define Stablen 128
#define Vtablen 128
#define Dirprd 16
#define Laid (Vtablen+Dirprd)

#define Lacnt 16

static struct sentry syntab[Stablen];
static ub1 vprdmap[Vtablen];
static ub2 syntabeas[Vtablen];

static ub2 stablen,vtablen;
static ub2 ndirprd,maxprdnam;

static ub1 lasetn[Lacnt];
static ub2 lasets[Lacnt * Laset];
static ub2 lasetln[Lacnt * Laset];

#define Invpos hi16
#define Repout (Invpos-1)

static ub2 nnterm,rulcnt,nrulcnt;
static cchar *nterms[Nnterm];
static ub1 ntlens[Nnterm];

static ub1 rul2nrul[Nnterm];
static ub1 nrul2rul[Nnterm];

static ub2 hintnamlen,himrgnamlen;

static ub2 prdsel[Nnterm * T99_count];

#define Mrgcnt 16

static char mrgnams[Mrgcnt * Ntnam];
static ub1  mrglens[Mrgcnt];
static ub1  mrglnos[Mrgcnt];
static ub2  mrgcnt;

static ub2 mrgbits[T99_count];
static ub1 tmpbits[T99_count];

static ub2 laseq;
static ub8 laseconds[Lacnt * T99_count * Laset];

static ub1 higrpdif;
static ub4 higrpfln;

static ub4 hiruldep;

static ub4 specdmin;
static ub4 specdtim;
static cchar *specmtime;

static cchar *tknam2(enum Token tk,bool hr)
{
  ub2 len;
  ub1 hc;
  static char basbuf[4 * 16];
  char *buf,*p,*q;
  static ub2 bufno;

  buf = basbuf + bufno * 16;
  bufno = (bufno + 1) & 3;

  if (tk > T99_count) return "*inv*";
  else if (tk == T99_count) return "count";
#if Kwcnt > 0
  else if (tk < T99_kwd) {
    memcpy(buf,kwnampool + kwnamposs[tk],len=kwnamlens[tk]);
    buf[len] = 0;
  }
#endif
  else {
    tk -= T99_kwd;
    hc = tokhrctl[tk] & 0xf;
    if (hc == 0 || hr == 0) return toknampool + toknampos[tk];
    len = tk * 4;
    p = hrtoknams + len;
    q = buf;
    while (hc--) *q++ = *p++;
    *q = 0;
  }
  return buf;
}

static bool tkdefarg(enum Token t) {
  if (t >= T99_kwd && t <= T1grp) return 1; // lits + op
  // else if (t < T99_kwd && t >= T99_mrg) return 1;
  else return 0;
}

static cchar *tknam(enum Token tk) { return  tknam2(tk,0); }

static cchar *atrnam(ub2 atr)
{
  static char buf[64];

  mysnprintf(buf,0,32,"%c%u.%c.%c.%x.%x",
    atr & Sa_nod ? '+' : '-',(atr >> 8) & 7,atr & Sa_rep ? '*' : ' ',atr & Sa_s0 ? '>' : ' ',(atr & Sa_si) >> 4,atr & Sa_len);
  return buf;
}

static cchar *printsec(ub8 sec,char *buf,ub4 blen)
{
  ub8 bit;
  enum Token t;
  ub2 pos = 0;

  *buf = 0;
  for (t = 0; t < T99_count; t++) {
    bit = 1UL << t;
    if (sec & bit) pos += mysnprintf(buf,pos,blen,"%s ",tknam(t));
  }
  return buf;
}

static bool memeq(const void *p,const void *q,ub2 n) { return !memcmp(p,q,n); }

static ub1 addnterm(cchar *name,ub1 len)
{
  if (nnterm+1 >= Nnterm) serror(Lno,"exceeding %u states",nnterm);
  nterms[nnterm] = name;
  ntlens[nnterm] = len;
  return nnterm++;
}

static ub1 getnterm(cchar *buf,ub2 pos,ub2 len)
{
  ub1 nt;

  for (nt = 0; nt < nnterm; nt++) {
    if (len == ntlens[nt] && memeq(nterms[nt],buf+pos,len)) break;
  }
  return nt;
}

static cchar *ntnam(ub1 nt)
{
  if (nt >= T99_count) serror(Lno,"term as nterm %u",nt);
  else if (nt >= nnterm) serror(Lno,"unknown nterm %u",nt);

  cchar *p = rules[nt].name;
  if (*p == 0) serror(Lno,"no name for nterm %u",nt);
  return p;
}

static cchar *symnam(ub1 s)
{
  if (s < T99_count) return tknam(s);
  else if (s < T99_count + nnterm) return ntnam(s - T99_count);
  else if (s >= T99_count + nnterm + mrgcnt) serror(Lno,"symbol %u out of range",s);
  s -= T99_count + nnterm;
  return mrgnams + s * Ntnam;
}

static ub2 getmrg(cchar *nam,ub1 nlen)
{
  ub2 mrg;

  for (mrg = 0; mrg < mrgcnt; mrg++) {
    if (mrglens[mrg] == nlen && memeq(nam,mrgnams + mrg * Ntnam,nlen)) return mrg;
  }
  return mrgcnt;
}

static ub2 addmrg(ub1 *tbits,cchar *nam,ub1 nlen,ub2 lno)
{
  bool have = 0;
  ub2 mrg,bit,cnt=0;
  enum Token tk,tk1=0;

  for (mrg = 0; mrg < mrgcnt; mrg++) { // check existing
    bit = 1U << mrg;
    have = 1;
    for (tk = 0; tk < T99_count && have; tk++) {
      if (tbits[tk] && !(mrgbits[tk] & bit)) have = 0;
      else if (!tbits[tk] && (mrgbits[tk] & bit)) have = 0;
    }
    if (have) break;
  }
  if (mrg < mrgcnt) return mrg;

  if (mrgcnt + 1 > Mrgcnt) serror(lno|Lno,"exceeding %u merge sets",mrgcnt);

  bit = 1U << mrg;
  for (tk = 0; tk < T99_count; tk++) {
    if (tbits[tk]) { cnt++; tk1 = tk; mrgbits[tk] |= bit; }
  }
  if (cnt == 1) serror(lno|Lno,"single-token %s merge set %u",tknam(tk1),mrg);
  mrglnos[mrg] = lno;
  memcpy(mrgnams + mrg * Ntnam,nam,nlen);
  mrglens[mrg] = nlen;
  if (nlen > himrgnamlen) himrgnamlen = nlen;
  svrb(lno|Lno,"new merge set %u %.*s",mrg,nlen,nam);
  mrgcnt++;
  return mrg;
}

static const ub1 bs = '\\';
static const ub1 nl = '\n';

#undef serror
#define serror2(fpos,nt,s,fmt,...) serrfln(FLN,fpos,nt,s,fmt,__VA_ARGS__)
#define serror(fpos,fmt,...) serrfln(FLN,fpos,nnterm+1,0xff,fmt,__VA_ARGS__)

#define swarn2(fpos,nt,s,fmt,...) sgenfln(FLN,Warn,fpos,nt,s,fmt,__VA_ARGS__)

#undef sinfo
#define sinfo2(fpos,nt,s,fmt,...) sinffln(FLN,fpos,nt,s,fmt,__VA_ARGS__)
#define sinfo(fpos,fmt,...) sinffln(FLN,fpos,nnterm+1,0xff,fmt,__VA_ARGS__)

#define svrb2(fpos,nt,s,fmt,...) sgenfln(FLN,Vrb,fpos,nt,s,fmt,__VA_ARGS__)

#undef sgenmsg
#define sgenmsg(lvl,fpos,nt,s,fmt,...) sgenfln(FLN,lvl,fpos,nt,s,fmt,__VA_ARGS__)

static void svgenmsg(ub4 fln,enum Msglvl lvl,ub4 fpos,ub2 nt,ub1 s,cchar *fmt,va_list ap)
{
  char buf[256];
  ub4 pos = 0;

  if (nt <= nnterm) pos = mysnprintf(buf,0,256,"rule %-12.*s ",ntlens[nt],nterms[nt]);
  if (s < T99_count + nnterm) pos += mysnprintf(buf,pos,256,"sym %-12s ",symnam(s));
  vmsgps(fln,lvl,fpos,fmt,ap,pos ? buf : nil,nil);
}

static Noret void __attribute__ ((format (printf,5,6))) serrfln(ub4 fln,ub4 fpos,ub2 nt,ub1 s,const char *fmt,...)
{
  va_list ap;

  va_start(ap,fmt);
  svgenmsg(fln,Error,fpos,nt,s,fmt,ap);
  va_end(ap);
  doexit(1);
}

static void __attribute__ ((format (printf,5,6))) sinffln(ub4 fln,ub4 fpos,ub2 nt,ub1 s,const char *fmt,...)
{
  va_list ap;

  va_start(ap,fmt);
  svgenmsg(fln,Info,fpos,nt,s,fmt,ap);
  va_end(ap);
}

static void __attribute__ ((format (printf,6,7))) sgenfln(ub4 fln,enum Msglvl lvl,ub4 fpos,ub2 nt,ub1 s,const char *fmt,...)
{
  va_list ap;

  va_start(ap,fmt);
  svgenmsg(fln,lvl,fpos,nt,s,fmt,ap);
  va_end(ap);
  if (lvl <= Error) doexit(1);
}

#if 0
static bool optrules(void)
{
  bool change = 0;
  ub2 r,rx;
  ub1 a,acnt;
  ub1 si,slen,hilen;
  ub1 s,sx,mrg,*sp;
  enum Ctl z,zx,zr,zxr,zn,*cp;
  struct rule *rp,*rxp;
  ub2 lno;
  ub1 syms[Nalt];
  enum Token t;
  ub2 tbit;
  ub1 tks[T99_count];
  char buf[32];
  ub2 pos;
  bool havent,haverep;

  nrulcnt = 0;

  for (r = 0; r < rulcnt; r++) { // each rule
    rp = rules + r;

    if (rp->ref == rulcnt) continue;

    lno = rp->lno;
    acnt = rp->altcnt;

    havent = haverep = 0;
    hilen = 0;

    for (a = 0; a < acnt; a++) { // each alt
      sp = rp->alts + a * Altlen;
      cp = rp->ctls + a * Altlen;
      slen = rp->altlens[a];

      hilen = max(hilen,slen);

      syms[a] = *sp;

      for (si = 0; si < slen; si++) {

        s = sp[si];
        z = cp[si];
        zr = z & Crepmask;
        if (zr) haverep = 1;

        if (s < T99_count) { // regular token

        } else if (s < T99_count + rulcnt) { // nonterm. Check trivial inline and merge set
          rx = s - T99_count;
          rxp = rules + rx;
          if (rxp->rulrep) {
            havent = 1;
            continue;
          }
          if (rxp->altcnt != 1 || rxp->altlens[0] != 1) {
            havent = 1;
            continue;
          }
          sx = rxp->alts[0];
          zx = rxp->ctls[0];
          zxr = zx & Crepmask;
          if (zr == Crep0n || zxr == Crep0n) zn = Crep0n;
          else zn = zr | zxr;
          if (zn) haverep = 1;
          zn |= (zx & Cidmask) | (z & Cidmask);
          sp[si] = sx;
          cp[si] = zn;

          if (si == 0) syms[a] = sx;

          if (sx >= T99_count && sx < T99_count + rulcnt) havent = 1;
          change = 1;
          sinfo2(lno|Lno,r,s,"inlining at pos %u",si);

        } else { // merge set
        }

      } // each si

    } // each alt

    if (rp->rulrep || hilen > 1 || havent || haverep || acnt == 1) continue;

    // convert to merge set
    memset(tks,0,T99_count);
    for (a = 0; a < acnt; a++) {
      s = syms[a];
      if (s < T99_count) tks[s]++;
      else if (s >= T99_count + rulcnt) {
        mrg = s - T99_count - rulcnt;
        tbit = 1U << mrg;
        for (t = 0; t < T99_count; t++) {
          if (mrgbits[t] & tbit) tks[t]++;
        }
      }
    }

    for (t = 0; t < T99_count; t++) {
      if (tks[t] > 1) serror2(lno|Lno,r,t,"duplicate token for %u alts",acnt);
    }
    pos = mysnprintf(buf,0,32,"_%.16s",rp->name);
    mrg = addmrg(tks,buf,pos,lno);
    rp->mrgset = mrg;
    rp->ref = rulcnt;
    change = 1;
  } // each rule

  if (change) return change;

  // mark unused rules and resequence
  for (r = 0; r < rulcnt; r++) rules[r].ref = rulcnt;

  for (r = 0; r < rulcnt; r++) {
    rp = rules + r;
    acnt = rp->altcnt;

    for (a = 0; a < acnt; a++) { // each alt
      sp = rp->alts + a * Altlen;
      cp = rp->ctls + a * Altlen;
      slen = rp->altlens[a];

      for (si = 0; si < slen; si++) {
        s = sp[si];
        z = cp[si];
        zr = z & Crepmask;
        if (zr) haverep = 1;

        if (s < T99_count) { // regular token

        } else if (s < T99_count + rulcnt) { // nonterm
          rx = s - T99_count;
          rxp = rules + rx;
          mrg = rxp->mrgset;
          if (mrg != 0xff) sp[si] = mrg;
          else rxp->ref = r;
        } else {
        }
      }
    }
  }

  for (r = 0; r < rulcnt; r++) {
    rp = rules + r;
    if (rp->ref == rulcnt) continue;
    rul2nrul[r] = nrulcnt;
    nrul2rul[nrulcnt] = r;
    nrulcnt++;
  }
  rp = rules + startrule;
  if (rp->ref == rulcnt) {
    rp->ref = startrule;
    rul2nrul[startrule] = nrulcnt;
    nrul2rul[nrulcnt++] = startrule;
  }
  showcnt("net rule",nrulcnt);
  return 0;
}
#endif

static ub2 lacnt;

enum Fset { Fs_prep,Fs_term,Fs_nterm,Fs_fin,Fs_second };
static const char fsnam[] = "PTNFS";

static bool do_sec2 = 1;

// create first and second sets
static bool mk12(enum Fset pass,ub2 iter)
{
  bool change = 0;
  ub2 i,cnt;
  ub2 r,rx;
  ub2 a,ax,acnt;
  ub1 si,lsi,slen,hisi,six,si2;
  ub1 lti,hti,loti,hiti,dlti,dhti;
  ub1 s,mrg,*sp;
  enum Ctl z,zr,*cp;
  struct rule *rp,*rxp,*prx;
  ub4 *tfp,*tfp0;
  ub4 *rfp,*rfp0;
  ub4 *ffp;
  ub8 tbit,*rsp,*rsp0,*rspm;
  ub2 *firstra;
  ub1 fn,fc,*firstrn,*firstrc;
  ub4 abit,aset;
  ub8 sec;
  ub2 lno;
  ub4 lnx;
  enum Token t,tf,ts;
  ub2 a8;
  bool dodir,dobenamb;
  ub1 tks[T99_count];
  ub2 tkcnt;

  ub1 tkfirst[T99_count];

  ub2 ofirstra[T99_count];
  ub1 ofirstrn[T99_count];
  ub8 osecond[Nsi * T99_count];

  vrb("pass %c iter %u",fsnam[pass],iter);

  memset(ofirstrn,0,sizeof(ofirstrn));

  for (r = 0; r < rulcnt; r++) {
    rp = rules + r;
    if (rp->ref == rulcnt) continue;

    lno = rp->lno;
    lnx = lno|Lno;
    acnt = rp->altcnt;

    firstra = rp->firstra;
    firstrn = rp->firstrn;
    firstrc = rp->firstrc;

    tfp0 = rp->tfirst0;
    rfp0 = rp->rfirst0;

    rspm = rp->second0;

    if (pass == Fs_fin) {
     for (si = 0; si < rp->hisi; si++) {
      tfp = rp->tfirst + si * T99_count;
      rfp = rp->rfirst + si * T99_count;
      ffp = rp->first  + si * T99_count;
      for (t = 0; t < T99_count; t++) {
        aset = tfp[t] | rfp[t];
        if (aset == 0) continue;
        ffp[t] = aset;
        rp->first0[t] |= aset;
//        svrb2(lnx,r,t,"si %u first %x",si,aset);
      }
     }
     continue;

    } else if (pass == Fs_nterm && change == 0) {
      memcpy(ofirstra,firstra,T99_count * 2);
      memcpy(ofirstrn,firstrn,T99_count);
    }

    loti = 0xff;
    hiti = 0;
    hisi = 0;

    for (a = 0; a < acnt; a++) { // each alt
      sp = rp->alts + a * Altlen;
      cp = rp->ctls + a * Altlen;
      slen = rp->altlens[a];
      abit = 1U << a;
      a8 = a << 8;

      lno = rp->lnos[a];
      lnx = lno|Lno;

      rsp0 = rsp = rp->second + a * Nsi * T99_count;

      if (pass == Fs_second && change == 0) {
        memcpy(osecond,rsp0,sizeof(osecond));
      }

      lsi = 0;
      si = 0;

      lti = hti = 0;

      memset(tkfirst,0,T99_count);

      prx = nil;

      do { // each si

        tfp = rp->tfirst + si * T99_count;
        rfp = rp->rfirst + si * T99_count;
        ffp = rp->first  + si * T99_count;

        s = sp[si];
        z = cp[si];
        zr = z & Crepmask;
        dlti = dhti = 1;

        dodir = (si + 1 == slen && zr == Crep11);
        dobenamb = ena_benambi && (zr == Crep11);

        tkcnt=0;
        if (s < T99_count) { // regular token
          tks[tkcnt++] = s;

        } else if (s >= T99_count + rulcnt) { // merge set
          mrg = s - T99_count - rulcnt;
          tbit = 1U << mrg;
          for (t = 0; t < T99_count; t++) {
            if (mrgbits[t] & tbit) tks[tkcnt++] = t;
          }

        } else if (s < T99_count + rulcnt) { // nonterm
          rx = s - T99_count;
          if (rx == r && pass == Fs_term) serror2(lnx,r,0xff,"alt %u si %u left-recursive rule",a,si);
          rxp = rules + rx;

          if (pass == Fs_prep && rxp->rulrep == 1) {
            zr = cp[si] = Crep0n;
          }

          dlti = rxp->lotcnt;
          dhti = rxp->hitcnt;

          if (pass == Fs_nterm) {
            cnt = 0;
            for (t = 0; t < T99_count; t++) {

              if (rxp->tfirst0[t] || rxp->rfirst0[t]) {
                cnt++;
//                svrb2(lnx,r,t,"alt %u r1 %u rfirst %lx",a,r1,rxp->tfirst0[t]);
                if ( (rfp[t] & abit) == 0) { rfp[t] |= abit; rfp0[t] |= abit; change = 1; }

                fn = rxp->firstrn[t];
                fc = rxp->firstrc[t];
                if (dobenamb) {
                  firstra[t] = rxp->firstra[t];
                  if (rxp->tfirst0[t]) firstrn[t] = 0;
                  else firstrn[t] = min(firstrn[t],fn + 1);
                  if (dodir && fc == 1) firstrc[t] = 1;
                  else if (fc == 2) {
                    firstrc[t] = 2;
                  }
                } else firstrc[t] = 3;
              } else if (iter == hi16) svrb2(lnx,r,t,"rule %s alt %u no first",rxp->name,a);
            }
            if (cnt == 0 && iter == hi16) swarn2(lnx,r,t,"rule %s alt %u no first",rxp->name,a);

          } else if (pass == Fs_second) {
            for (t = 0; t < T99_count; t++) {
              if (lti == 0) {
                if (rxp->first0[t] == 0) continue;
                tkfirst[t] = 1;
                for (ax = 0; ax < rxp->altcnt; ax++) {
                  for (six = 0; six < Nsi; six++) rsp[t] |= rxp->second[(ax * Nsi + six) * T99_count + t];
                }
                rspm[t] |= rxp->second0[t];

                fc = firstrc[t];
                if (dobenamb) {
                  if (fc == 2) {
                    sec = rxp->secr[t];
                    sec |= rsp[t];
                    rp->secr[t] |= sec;
                  }
                }
              }
              if (lti == 1 || hti == 1) {
                if (tkfirst[t] == 0) continue;
                for (ts = 0; ts < T99_count; ts++) {
                  tbit = 1UL << ts;
                  if (rxp->first0[ts]) { rsp[t] |= tbit; rspm[t] |= tbit; }
                }
              }
              if (do_sec2 && prx && prx->lotcnt == 1 && rxp->first0[t]) {
                tbit = 1UL << t;
                if ( (prx->secadd & tbit) == 0) { prx->secadd |= tbit; change = 1; }
              }
              prx = rxp;
            } // each tf
          } // second
        } // nonterm

        // terms
        for (i = 0; i < tkcnt; i++) {
          t = tks[i];
          if (pass == Fs_term) {
            tfp[t]  |= abit;
            tfp0[t] |= abit;
            if (dodir) {
              svrb2(lnx,r,t,"alt %u first %x",a,tfp0[t]);
              if (firstra[t] == hi16) {
                firstra[t] = r | a8;
                firstrn[t] = 0;
                firstrc[t] = (si == slen - 1 && zr == Crep11 ? 1 : 3);
              } else firstrc[t] = 3; // block on ambi
            }

          } else if (pass == Fs_second) {
            tbit = (1UL << t);
            if (lti == 0) {
              tkfirst[t] = 1;
              svrb2(lnx,r,t,"first %u for %u %u",t,lti,hti);
            }
            if (lti == 1 || hti == 1) {
              for (tf = 0; tf < T99_count; tf++) {
                if (tkfirst[tf]) {
                  rsp[tf] |= tbit; rspm[tf] |= tbit;
                }
              }
            }
            if (do_sec2 && prx && prx->lotcnt == 1) {
              if ( (prx->secadd & tbit) == 0) { prx->secadd |= tbit; change = 1; }
            }
            prx = nil;
          } // second
        } // each tk

        if (pass == Fs_second) {
          if (lti == 1 || hti == 1) memset(tkfirst,0,T99_count);
        }

        rsp = rsp0 + si * T99_count;

        switch (zr) {
        case Crep11: si++; lsi++; lti += dlti; hti += dhti; break;
        case Crep0n: si++;        hti += dhti * 2; break;
        case Creplp:
        case Crep01: si++;        hti += dhti;     break;

        case Crep02: si += 2;     hti += dhti + 1; break;
        case Crep03: si += 3;     hti += dhti + 2; break;
        case Crep04: si += 4;     hti += dhti + 3; break;
        case Crep05: si += 5;     hti += dhti + 4; break;
        default: serror(lnx,"pos %u unknown repcode %u",si,zr);
        }

        if (pass == Fs_term || pass == Fs_nterm) {
          rp->hisis[a] = si;
          hisi = max(hisi,si);
          if (lsi == 1) break;
          if (si >= Nsi) serror2(lnx,r,0xff,"exceeding %u optional leading symbols",Nsi);
        }
      } while (si < slen);

      if (lti == 0) {
        if (pass == Fs_term && r != startrule) serror2(lnx,r,0xff,"alt %u/%u can be empty - len %u..%u",a,acnt,lti,hti);
      }

      loti = min(loti,lti);
      hiti = max(hiti,hti);

      rp->ltis[a] = lti;

      // add in possible seconds after end of nterm
      if (pass == Fs_second && lti == 1) {
        for (tf = 0; tf < T99_count; tf++) {
          if ( (rp->first0[tf] & abit) == 0) continue;
          for (t = 0; t < T99_count; t++) {
            tbit = 1UL << t;
            if ( (rp->secadd & tbit) == 0) continue;
            if ( (rspm[tf] & tbit) == 0) { rspm[tf] |= tbit; change = 1; }
            for (si2 = 0; si2 <= hisi; si2++) {
              rsp = rsp0 + si2 * T99_count;
              if (rsp[tf] & tbit) continue;
              rsp[tf] |= tbit; change = 1;
            }
          }
        }

#if 0
        for (tf = 0; tf < T99_count; tf++) {
          for (t = 0; t < T99_count; t++) {
            if (rspm[tf] & (1UL << t)) sinfo2(lnx,r,tf,"second %s",tknam(t));
          }
        }
#endif

      } else if (pass == Fs_second) {
        if (change == 0 && memcmp(osecond,rsp0,sizeof(osecond)) ) change = 1;
      }

    } // each alt
    rp->hisi = hisi;

//   if (pass == Fs_second) {
//   }

//   if (pass == Fs_term pass == Fs_nterm) {
//   }

    if (pass == Fs_prep) {
      if (rp->lotcnt != loti /* || rp->hitcnt != hiti */) change = 1;
      svrb2(lnx,r,0xff,"ti lo %u/%u hi %u",loti,rp->lotcnt,hiti);
      rp->lotcnt = loti;
      if (iter == 0) {
        rp->hitcnt = hiti;
        memset(firstra,0xff,T99_count * 2);
        memset(firstrn,0,T99_count);
      }

    } else if (pass == Fs_nterm && change == 0) {
      if (memcmp(ofirstrn,firstrn,T99_count)) change = 1;
      if (change || memcmp(ofirstra,firstra,T99_count * 2)) change = 1;
    }

  } // each rule

  if (pass != Fs_fin) return change;

  return change;
}

static int mkfirstsec(void)
{
  ub2 iter;

  iter=0; while (mk12(Fs_prep,iter) && ++iter < 50) ;

  mk12(Fs_term,0);

  iter=0; while (mk12(Fs_nterm,iter) && ++iter < 50) ;
  mk12(Fs_nterm,hi16);

  mk12(Fs_fin,0);

  if (lareqs == 0) return 0;

  iter=0; while (mk12(Fs_second,iter) && ++iter < 50) ;
  return 0;
}

static ub2 tkrefs[T99_count];

static bool doentry(struct rule *rp,struct sentry *ep,ub1 *sp,ub1 *cp,ub1 *ap,ub2 len,bool need)
{
  ub2 si = 0;
  ub1 s,*ds,*dc;
  ub1 z,repc;
  ub1 a;
  bool s0=0,islp;
  struct rule *rxp;
  ub4 lnx = ep->lno|Lno;

  s = sp[0];
  z = cp[0];
  a = ap[0];
  repc = z & Crepmask;

  if (s >= T99_count && s < T99_count + rulcnt) need = 1;
  if (need == 0 && len > 1 && repc == Crep11) {
    svrb2(rp->lno|Lno,rp->id,*sp,"len %u",len);
    s0 = 1;
    len--;
    sp++;
    cp++;
    ap++;
  }

  ds = ep->syms;
  dc = ep->ctls;
  ep->len = len;

  for (si = 0; si < len; si++) {
    s = sp[si];
    z = cp[si];
    a = ap[si] & 0xf;
    islp = (z & Crepmask) == Creplp;
    if (islp && len > 1 && si < len-1) serror(lnx,"rule %s: duplicate end of rep",rp->name);
    if (s >= T99_count && s < T99_count + rulcnt) {
      if (islp) serror2(lnx,rp->id,s,"si %u +x repeat on nonterm",si);
      rxp = rules + s - T99_count;
      if (rxp->rulrep) z &= Cargmask;
      s = rul2nrul[s - T99_count] + T99_count;
    }
//    svrb2(rp->lno|Lno,rp->id,s,"%u si %u z %x",s,si,z);
    if (a != 0xf) { z |= (a+1); svrb2(lnx,rp->id,s,"arg %u",a); }
    ds[si] = s;
    dc[si] = z;
  }
  return s0;
}

#define Dirprdnam (Ntnam + Tknamlen + 2)

static ub2 dirtoks[Nnterm * Nalt];
static ub2 dirtkruls[Dirprd];
static ub1 dirtks[Dirprd];

static ub1 dirprdnams[Dirprd * Dirprdnam];
static ub1 dirprdnlens[Dirprd];

static ub2 addirtok(enum Token tk,ub2 rul,ub2 alt,bool arg)
{
  ub2 ndx = rul * Nalt + alt;
  ub2 d = dirtoks[ndx];
  ub2 *dtr;
  ub1 *np;
  ub1 *nlp;
  ub2 len;
  ub4 lnx = rules[rul].lno|Lno;

  dtr = dirtkruls;
  if (d == hi16) {
    if (ndirprd >= Dirprd) serror2(lnx,rul,tk,"exceeding %u dir tokens",Dirprd);
    d = ndirprd++;
    sinfo2(lnx,rul,tk,"add dirtok %u alt %u",d,alt);
  }  else sinfo2(lnx,rul,tk,"dirtok %u alt %u",d,alt);
  np = dirprdnams + d * Dirprdnam;
  nlp = dirprdnlens;

  dirtoks[ndx] = d;
  dtr[d] = rul;
  dirtks[d] = tk;
  len = mysnprintf(np,0,Dirprdnam,"%s_%s",tknam(tk),ntnam(rul));
  svrb2(lnx,rul,tk,"add dir %u '%s' alt %u",d,np,alt);
  nlp[d] = len;
  if (len > maxprdnam) maxprdnam = len;
  return d + Stablen;
}

/* create the sentry and prdsel tables

  One rule N -> S0 .. Sn for each nonterm N and symbols S0..n being either nonterm or term aka token

  prdsel[rule,token] points to sentry with production, or direct code if single

  syntab[se] contains production S1 .. Sn and repetition / grouping controls C1 .. n

  special conditions:

  N -> S0? S1 ...    stbl [N,S0] points to sentry x.   = S1 ...
                          [N,S1] points to sentry x+1  = S2 ...    */

static int mktables(void)
{
  struct rule *rp,*rxp;
  struct sentry *ep;
  ub2 se=0,ve=0,ose,nse;
  enum Token tk;
  enum Ctl repc,idc;
  ub1 arg,hiarg=0;
  ub2 atr;
  ub1 z,*cp;
  ub1 *ap;
  ub2 x2,*stp = prdsel;
  ub2 rx,tr,r,nr=0,ta;
  ub2 acnt,slen,a,aa;
  ub1 s,*sp;
  ub2 cnt,si,sinc,i,n;
  ub2 lno,hiargln = 0;
  ub4 lnx;
  ub4 mrgbit;
  ub1 laid,laid2;
  ub1 lasn;
  ub2 lasi;
  bool dola;
  bool doarg;
  ub2 narg;
  ub4 *xfp;
  ub8 sec,*lasp,*lasp2,*rsp,*rsp0,*xsp;
  bool isrep,nosingle;
  ub1 rulrep;
  enum Token tks[T99_count];
  bool tkdup[T99_count];
  ub2 tra,tfra[T99_count];
  ub1 trn,tfrn[T99_count];
  ub1 tnc,tfnc[T99_count];
  ub8 tentsec[T99_count];
  ub2 tentlno[T99_count];
  bool havent,haveve;
  ub2 dircnt = 0,vecnt = 0;
  ub2 blen = 512;
  char buf[512];

  sassert(Stablen < 0x8000,"Stablen < 32K required");

  memset(prdsel,0xff,sizeof(prdsel));
  memset(dirtoks,0xff,sizeof(dirtoks));
  memset(lasets,0xff,sizeof(lasets));

  memset(tentlno,0,sizeof(tentlno));
  memset(tentsec,0,sizeof(tentsec));

  for (r = 0; r < rulcnt; r++) { // each rule
    rp = rules + r;
    if (rp->ref == rulcnt) continue;

    if (r == startrule) startve = ve;

    lno = rp->lno;
    lnx = lno|Lno;
    acnt = rp->altcnt;

    nr = rul2nrul[r];

    rulrep = rp->rulrep;
    havent = 0;

    svrb2(lnx,r,0xff,"rule %u alts %u ep %u",r,acnt,se);

    stp = prdsel + nr * T99_count;

    for (a = 0; a < acnt; a++) { // each alt
      ep = syntab + se;
      aa = a * Altlen;
      sp = rp->alts + aa;
      cp = rp->ctls + aa;
      ap = rp->args + aa;

      slen = rp->altlens[a];
      lno = rp->lnos[a];
      lnx = lno|Lno;
      dola = rp->dolas[a];
      narg = rp->argcnts[a];

      rsp0 = rp->second + a * Nsi * T99_count;

      if (lno == 0) serror2(lnx,r,T99_count,"rule %u alt %u no line",r,a);

      if (slen == 0) serror2(lnx,r,T99_count,"rule %u alt %u empty",r,a);
      else if (slen >= Slen) serror2(lnx,r,T99_count,"alt %u len %u exceeds %u",a,slen,Slen);

      if (se + 1 >= Stablen) serror2(lnx,r,T99_count,"syntab exceeds max len %u",Stablen);

      if (narg && rp->prdnlen[a] == 0) sinfo2(lnx,r,T99_count,"alt %u has no name and %u args",a,narg);

     si = 0;
     while (si < slen) {
      rsp = rsp0 + si * T99_count;

      s = sp[si];
      z = cp[si];
      repc = z & Crepmask;
      idc = z & Cidmask;

      sinc = 1;
      isrep = 0;
      switch (repc) {
      case Crep11: break;
      case Crep0n: isrep = 1; break;
      case Crep01: case Crep02: case Crep03: case Crep04: case Crep05:
        isrep = 1;
        sinc = repc >> Crepshift; break;
      case Creplp: break;
      default: break;
      }

      nosingle = isrep || idc || rulrep;

      if (isrep && si + sinc == slen) serror2(lnx,r,s,"alt %u possible empty prod",a);

      cnt=0;

      memset(tkdup,0,T99_count);

      // collect token set
      if (s >= T99_count + rulcnt) { // merged tokens
        s -= T99_count + rulcnt;
        if (s >= mrgcnt) serror2(lnx,r,T99_count,"invalid mrg set %u",s);

        mrgbit = 1U << s;

        for (tk = 0; tk < T99_count; tk++) {
          if (mrgbits[tk] & mrgbit) {
            tfra[cnt] = rp->firstra[tk];
            tfrn[cnt] = rp->firstrn[tk];
            tfnc[cnt] = rp->firstrc[tk];
            tks[cnt++] = tk;
          }
        }
        if (cnt == 0) serror2(lnx,r,sp[si],"no first for mrg %u",s);

      } else if (s < T99_count) { // regular token
        tfra[cnt] = rp->firstra[s];
        tfrn[cnt] = rp->firstrn[s];
        tfnc[cnt] = rp->firstrc[s];
        tks[cnt++] = s;

      } else { // nonterm
        havent = 1;
        rx = s - T99_count;
        rxp = rules + rx;
        xfp = rxp->first0;

        if (rxp->rulrep) {
          nosingle = 1;
        }
        for (tk = 0; tk < T99_count; tk++) { // fill tokens from First
          if (xfp[tk] == 0) continue;
          tra = rxp->firstra[tk];
          tfra[cnt] = tra;
          tfrn[cnt] = rxp->firstrn[tk];
          tfnc[cnt] = (si + 1 == slen && repc == Crep11 ? rxp->firstrc[tk] : 3);
          tks[cnt++] = tk;
        }
        if (cnt == 0) serror2(lnx,r,T99_count,"no first for alt %u rule %s",a,rxp->name);
      }

      doarg = (ap[si] & 0xf) != 0xf;

      // fill prdsel
      haveve = 0;
      for (i = 0; i < cnt; i++) {
        tk = tks[i];
        if (tkdup[tk]) serror2(lnx,r,tk,"alt %u dup token",a);
        tkdup[tk] = 1;
        tra = tfra[i];
        trn = tfrn[i];
        tnc = tfnc[i];
        tr = tra & 0xff;
        ta = tra >> 8;
        ose = stp[tk];

        if (tnc == 1) { // dirtok todo isrep
          rxp = rules + tr;
          xsp = rxp->second0;
          svrb2(lnx,tr,tk,"i %u rule %s",i,rp->name);
          sec = xsp[tk];
          nse = addirtok(tk,tr,ta,doarg);
          svrb2(lnx,r,tk,"i %u nse %u sec %s",i,nse,printsec(sec,buf,blen));
          dircnt++;

        } else if (ena_benambi && tnc == 2 && trn > 2 && ose == Invpos) { // dirtok + benamb
          rxp = rules + tr;
          nse = addirtok(tk,tr,ta,doarg);
          if (laseq + 1 >= Lacnt) serror2(lnx,r,tk,"exceeding %u lookahead sets",Lacnt);
          laid = laseq++;
          stp[tk] = ose = laid + Laid;
          ep->la |= (1U << laid);
          svrb2(lnx,r,tk,"new benamb laid %u for %u",laid,nse);
          lasp = laseconds + (laid * T99_count + tk) * Laset;
          lasets [laid * Laset] = nse;
          lasetln[laid * Laset] = lno;
          sec = ~rxp->secr[tk];
          lasp[0] = sec;
          svrb2(lnx,r,tk,"la %u.0 sec %s",laid,printsec(sec,buf,blen));
          lasetn[laid] = 1;

          vecnt++;
          nse = ve;
          sec = rsp[tk];
          haveve = 1;

        } else {
          vecnt++;
          nse = ve;
          sec = rsp[tk];
          svrb2(lnx,r,tk,"alt %u si %u ve %u sec %lx",a,si,ve,sec);
          haveve = 1;
        }

        svrb2(lnx,r,tk,"ose %u nse %u",ose,nse);

        if (ose == Invpos) { // regular assign
          stp[tk] = nse;
          tentsec[tk] = sec;
          tentlno[tk] = lno;
          svrb2(lnx,r,tk,"alt %u bas ep %u ts %lx",a,stp[tk],sec);

        } else if (ena_lookahead && dola == 1) { // assign la
          if (ose == Repout) serror2(lnx,r,tk,"alt %u ambiguous end rep",a);
          if (ose >= Laid) laid = ose - Laid;
          else {
            if (laseq + 1 >= Lacnt) serror2(lnx,r,tk,"exceeding %u lookahead sets",Lacnt);
            laid = laseq++;
            stp[tk] = laid + Laid;
            ep->la |= (1U << laid);
            svrb2(lnx,r,tk,"new laid %u for %u vs %u",laid,ose,nse);
          }

          if (sec == 0) {
            swarn2(lnx,r,tk,"nil sec for la %u",laid);
          }

          lasn = lasetn[laid];
          lasp = laseconds + (laid * T99_count + tk) * Laset;
          if (lasn >= Laset) { swarn2(lnx,r,tk,"exceeding %u lookahead set size",Laset); continue; }
          else if (lasn == 0) {
            if (tentsec[tk] == 0) serror2(lnx,r,tk,"la %u.%u empty set on %lx",laid,lasn,lasp[0]);
            lasets [laid * Laset] = ose;
            lasetln[laid * Laset] = tentlno[tk];
            svrb2(lnx,r,tk,"la %u.%u %lx | %lx",laid,lasn,lasp[0],tentsec[tk]);
            lasp[0] |= tentsec[tk];
            lasn = 1;
          }
          vrb("ose %u se %u",ose,se);

          for (n = 1; n < lasn; n++) {
            if (lasets[Laset * laid + n] == nse) break;
          }
          vrb("n %u lasn %u",n,lasn);
          lasp[n] |= sec;
          if (n == lasn) {
            sec = lasp[0];
            for (n = 1; n < lasn; n++) { // check ambiguity
              if (lasp[n] == sec) serror2(lnx,r,tk,"laid %u.%u at ln %u ambiguous",laid,n,lasetln[laid * Laset]);
            }
            lasets [laid * Laset + lasn] = nse;
            lasetln[laid * Laset + lasn] = lno;
            lasetn [laid] = lasn + 1;
            svrb2(lnx,r,tk,"lookahead set %u.%u for %u",laid,lasn,se);
          }
        } else if (dola == 0) serror2(lnx,r,tk,"ambiguous choice at ln %u",tentlno[tk]);
      } // each tk

      if (haveve) {
        if (ve + 1 >= Vtablen) serror2(lnx,r,T99_count,"exceeding max %u productions",Vtablen);
        svrb2(lnx,r,0xff,"alt %u se %u rep %u need0 %u",a,se,isrep,nosingle);
        atr = slen;
        if (si == 0) {
          ep->nt0 = nr;
          ep->lno = lno;
          ep->alt = a;
          ep->s0 = sp[0];
          ep->ve0 = ve;
          if (doentry(rp,ep,sp,cp,ap,slen,nosingle)) atr = Sa_s0 | (slen - 1);
        } else if (si > 3) serror2(lnx,r,0xff,"si %u above %u",si,3);
        vprdmap[ve] = se;
        // ep->ve1 = ve;
        ep->nve++;
        atr |= (si << 4);
        if (rulrep) atr |= Sa_rep;
        atr |= (narg << 8);
        if (rp->prdid[a]) atr |= Sa_nod;
        syntabeas[ve] = atr;
        ve++;
      }

      if (isrep == 0) break;
      si += sinc;
     } // each symbol

     while (laseq > 1) { // remove dups
       laid2 = laseq - 1;
       laid = laseq - 2;
       lasn = lasetn[laid];
       if (lasn == lasetn[laid2] && memeq(lasets + laid * Laset,lasets + laid2 * Laset,Laset)) {
         for (tk = 0; tk < T99_count; tk++) {
           lasp  = laseconds + (laid  * T99_count + tk) * Laset;
           lasp2 = laseconds + (laid2 * T99_count + tk) * Laset;
           for (n = 0; n < lasn; n++) {
             sec = lasp2[n];
             if (sec) {
               lasp[n] |= sec;
               if (stp[tk] == laid2 + Laid) stp[tk] = laid + Laid;
             }
           }
         }
         laseq--;
         svrb2(lnx,r,0xff,"remove dup la %u",laseq);
       } else break;
     }

     if (ep->len) se++;
    } // each alt

    if (rulrep) { // mark invalids as 'out of repeat'
      for (tk = 0; tk < T99_count; tk++) { if (stp[tk] == Invpos) stp[tk] = Repout; }
    }

    if (rp->maxlen == 1 && havent == 0) swarn2(lnx,r,T99_count,"no nterms for %u alts",acnt); // single terms only: always expanded

  } // each rule

  stablen = se;
  vtablen = ve;
  showcnt("3prod",stablen);
  showcnt("3vprod",vtablen);
  showcnt("3la",laseq);
  showcnt("3#dir entries",dircnt);
  showcnt("3#ve entries",vecnt);

  if (higrpdif) sinfo(higrpfln,"longest opt group %u",higrpdif);

  lacnt = laseq;

  showcnt("3dirprd",ndirprd);

  // patch tbl len now we know it
  for (r = 0; r < rulcnt; r++) {
    rp = rules + r;
    if (rp->ref == rulcnt) continue;

    nr = rul2nrul[r];

    stp = prdsel + nr * T99_count;
    for (tk = 0; tk < T99_count; tk++) {
      x2 = stp[tk];
      if (x2 < Stablen || x2 >= Repout) continue; // regualar

      x2 -= Stablen;
      if (x2 < Dirprd) {
        x2 += vtablen; // dirprd
      } else {
        x2 = x2 - Dirprd + ndirprd + vtablen; // la
      }
      stp[tk] = x2;
    }
  }

  for (lasi = 0; lasi < lacnt * Laset; lasi++) {
    x2 = lasets[lasi];
    if (x2 < Stablen || x2 >= Repout) continue;
    x2 -= Stablen;
    if (x2 < Dirprd) {
      x2 += vtablen;
    } else {
      x2 = x2 - Dirprd + ndirprd + vtablen;
    }
    lasets[lasi] = x2;
  }

  return 0;
}

enum Specstate { Sout,Scmt,Smcmt,
  Svarnam,Svarnam1,Svarval,
  Srule0,Srule1,Srule2,Srule3,
  Spat0,Spat1,Spat2,Spat3,Spat4,Spat5,Spat6,Scount
};

#define Specvlen 32
static char specversion[Specvlen];
static char specdate[Specvlen];
static char specreq[Specvlen];
static char specauthor[Specvlen];
static char speclang[Specvlen];
static char specxdate[64];
static ub4 minver;

static char startrulnam[Specvlen];

enum Specvar { Sv_version,Sv_author,Sv_date,Sv_requires,Sv_lang,Sv_minver,Sv_start,Sv_table,Sv_count };

static const char *svnames[Sv_count] = {
 [Sv_version] = "version",
 [Sv_author] = "author",
 [Sv_date] = "date",
 [Sv_requires] = "requires",
 [Sv_lang] = "language",
 [Sv_minver] = "minver",
 [Sv_start] = "start",
 [Sv_table] = "table"
};

static ub2 svfpos[Sv_count];

static enum Specvar getvar(ub2 lno,cchar *src,ub2 nam0,ub2 nam1)
{
  ub2 namlen,nlen;
  enum Specvar sv,sv2;
  enum Msglvl lvl = Warn;
  cchar *p;
  char *q;

  if (nam1 <= nam0) serrorfln(FLN,lno|Lno,"invalid length %u-%u for var name",nam0,nam1);
  namlen = nam1 - nam0;
  if (namlen > 64) serrorfln(FLN,lno|Lno,"invalid length %u for var name",namlen);

  for (sv = 0; sv < Sv_count; sv++) {
    nlen = strlen(svnames[sv]);
    if (namlen == nlen && memeq(svnames[sv],src+nam0,namlen)) break;
  }

  if (sv == Sv_table) {
    for (sv2 = 0; sv2 < Sv_count; sv2++) {
      if (svfpos[sv2] == 0) {
        switch (sv2) {
        case Sv_start:    lvl = Error; break;
        case Sv_date:     lvl = Vrb; break;
        case Sv_version:
        case Sv_minver:
        case Sv_author:
        case Sv_requires: lvl = Info; break;
        case Sv_lang:     lvl = Warn; break;
        case Sv_table:    lvl = Nolvl; break;
        case Sv_count: break;
        }
        genmsg(lvl,"var %s undefined",svnames[sv2]);
      }
    }
    if (*speclang == 0) {
      p = specname;
      q = speclang;
      while (*p && *p != ' ') *q++ = *p++;
    }
  }

  switch (sv) {
  case Sv_count: serrorfln(FLN,lno|Lno,"unknown var '%.*s'",namlen,src+nam0);
  case Sv_table:
  case Sv_version:
  case Sv_author:
  case Sv_date:
  case Sv_requires:
  case Sv_lang:
  case Sv_minver:
  case Sv_start:
    if (svfpos[sv]) {
      serrorfln(FLN,lno|Lno,"var %s redefined",svnames[sv]);
      sinfo0(svfpos[sv]|Lno,"previously defined");
    }
  }
  svfpos[sv] = lno;
  return sv;
}

static bool chkver(cchar *p,ub2 len)
{
  while (len && (*p < '0' || *p > '9') ) { p++; len--; }
  ub4 ver = parse_version(version,sizeof(version));
  ub4 chk = parse_version(p,len);

  vrb("'%s' = %x",version,ver);
  vrb("'%.*s' = %x",len,p,chk);

  return check_version(chk,ver);
}

static void getval(enum Specvar sv,cchar *p,ub4 nam0,ub4 namlen,ub2 val0,ub2 val1)
{
  ub2 vallen;
  char *d;

  if (val1 <= val0) serrorfln(FLN,val0,"invalid length %u-%u for var %.*s",val0,val1,namlen,p+nam0);
  vallen = val1 - val0;
  if (vallen >= Specvlen) serrorfln(FLN,val0,"length %u for var %.*s above %u",vallen,namlen,p+nam0,Specvlen);

  switch (sv) {
  case Sv_version:  d = specversion; break;
  case Sv_author:   d = specauthor;  break;
  case Sv_date:     d = specdate;    break;
  case Sv_lang:     d = speclang;    break;
  case Sv_requires: d = specreq;
                    if (chkver(p+val0,vallen) == 0) serror(val0,"required version %.*s incompatible with current %s",vallen,p+val0,version);
                    break;
  case Sv_start:    d = startrulnam; startrnlen = vallen; break;
  case Sv_minver:   minver = atou(p + val0,vallen); info("minver %u",minver); return;

  default: return;
  }
  memcpy(d,p+val0,vallen);
}

static enum Token gettoken(cchar *nam,ub2 len)
{
  enum Token tk;
  ub2 tpos=0,tpos2,tlen;
  cchar *p;

  if (len == 0) serrfln(FLN,Lno,nnterm,0xff,"zero length for token");

#if Kwcnt > 0
  for (tk = 0; tk < T99_kwd; tk++) {
    if (len != kwnamlens[tk]) continue;
    tpos = kwnamposs[tk];
    if ((*nam | 0x20) == kwnampool[tpos] && memeq(kwnampool+tpos+1,nam+1,len-1)) return tk;
  }
#endif

  for (tk = 0; tk < T99_count - T99_kwd; tk++) {
    if (Ctab[*nam] == Calpha) {
      tpos  = toknampos[tk];
      tpos2 = toknampos[tk+1];
      tlen = tpos2 - tpos - 1;
      if (len != tlen) continue;
      if ((*nam | 0x20) == toknampool[tpos] && memeq(toknampool+tpos+1,nam+1,len-1)) return tk + T99_kwd;
    } else {
      tlen = tokhrctl[tk] & 0xf;
      if (len != tlen) continue;
      p = hrtoknams + 4 * tk;
      if (memeq(p,nam,len)) return tk + T99_kwd;
    }
  }

  return T99_count;
}

static ub2 ntrefs[Nnterm];
static ub2 ntdefs[Nnterm];

static void addrules(cchar *src,ub2 n,ub2 ln)
{
  ub1 c,d;
  ub2 nam0=0,len;
  ub2 lno = ln;
  ub2 r;
  enum Ctype t;
  struct rule *rp;

  while (src[n] && src[n] != '\n') n++;

  do {
    c=src[n];
    if (c == 0) break;
    d=src[n+1];
    t = Ctab[c];
    switch (t) {
    case Calpha: nam0 = n; break;
    case Chsh:   if (d == '#') {
                   n++; do { n++; } while (src[n] && !(src[n] == '#' && src[n+1] == '#') );
                 }
                 break;
    case Cnl:    lno++; break;
    default:     break;
    }
    if (src[n] == 0) break;
    n++;

//   info("n %u t %u",n,t);
   if (t == Calpha) {

    do {
      t = Ctab[src[++n]];
    } while (t == Calpha || t == Cnum);

    len = n - nam0;

    svrb(lno|Lno,"add rule %u %.*s",nnterm,len,src+nam0);

    if (len + 1 >= Ntnam) serrorfln(FLN,lno|Lno,"rule name '%.*s' exceeds len %u",Ntnam,src+nam0,Ntnam);
    r = getnterm(src,nam0,len);
    if (r < nnterm) serror2(lno|Lno,r,0xff,"rule %.*s redefined",len,nterms[r]);
    vrb("add rule %u %.*s",r,len,src+nam0);
    r = addnterm(src+nam0,len);
    if (ntdefs[r]) serror2(lno|Lno,r,0xff,"rule %u at line %u redefined",r,ntdefs[r]);
    ntdefs[r] = lno;
    rp = rules + r;
    rp->id = r;
    memcpy(rp->name,src+nam0,len);
    rp->lno = lno;
    rp->mrgset = 0xff;
    rul2nrul[r] = r;
    nrul2rul[r] = r;

    nam0 = 0;
   } else if (t == Cnl) continue;

    while (src[n] && src[n] != '\n') n++;
  } while (1);

  rulcnt = nrulcnt = nnterm;

  if (rulcnt == 0) serrorfln(FLN,Lno,"no rules");
//  if (rulcnt == 1) serrorfln(FLN,Lno,"only one rule");

  vrb("%u rules",rulcnt);
}

static bool doargs(void)
{
  struct rule *rp,*rxp;
  enum Token tk;
  ub1 hirarg,hiarg=0;
  ub1 z,*cp;
  ub1 arg,*ap;
  ub2 rx,r,hidepr=0;
  ub2 acnt,slen,a,aa;
  ub1 s,*sp;
  ub2 si,i,n;
  ub2 lno,hiargln = 0;
  ub4 lnx;
  bool doarg,change=0;
  ub1 narg;
  static ub2 iter;
  ub2 rr,rul2 = rulcnt * rulcnt;
  ub1 hidep=0;
  ub1 *ruldep = minalloc(rul2,1,0,"ruldep");

  vrbo("doargs iter %u",iter++);

  for (r = 0; r < rulcnt; r++) { // each rule
    rp = rules + r;
    if (rp->ref == rulcnt) continue;

    lno = rp->lno;
    lnx = lno|Lno;
    acnt = rp->altcnt;
    rr = r * rulcnt;

    hirarg=0;
    for (a = 0; a < acnt; a++) { // each alt
      aa = a * Altlen;
      sp = rp->alts + aa;
      cp = rp->ctls + aa;
      ap = rp->args + aa;

      slen = rp->altlens[a];
      lno = rp->lnos[a];
      lnx = lno|Lno;

      narg = 0;

     for (si = 0; si < slen; si++) {
      s = sp[si];
      z = cp[si];
      arg = ap[si];
      if (arg & 0x80) { // manual assign
        arg &= 0x7f;
        if (arg == 0xf) continue;
        if (arg < narg) serror2(lnx,r,s,"arg %u already assigned",arg);
        narg = arg + 1;
        continue;
      }

      doarg = 0;
      if (s >= T99_count + rulcnt) { // merged tokens
        doarg = 1;
      } else if (s < T99_count) { // regular token
        if (tkdefarg(s)) { doarg = 1; svrb2(lnx,r,s,"def arg for %u",s); }
      } else { // nonterm
        rx = s - T99_count;
        rxp = rules + rx;
        if (rxp->argcnt) {
          doarg = 1;
          svrb2(lnx,r,s,"rule arg for %u",s);
          if (ruldep[rr + rx] == 0) {
            ruldep[rr + rx] = rxp->hidep + 1;
            rp->hidep = max(rp->hidep,ruldep[rr + rx]);
          }
        }
      }

      if (doarg) {
        ap[si] = narg++;
        // sinfo2(lnx,r,s,"arg %u",ap[si]);
      } else ap[si] = 0xf;
      if (narg > Nodarg) serror2(lnx,r,0xff,"exceeding %u node args",Nodarg);
     } // each symbol

     if (rp->argcnts[a] != narg) change = 1;
     rp->argcnts[a] = narg;
     if (narg) {
       if (narg > hirarg) hirarg = narg;
       if (narg > hiarg) { hiarg = narg; hiargln = lno; }
       if (rp->argcnt < hirarg) {
         change = 1;
         rp->argcnt = hirarg;
       }
     }
    } // each alt

    rp->argcnt = hirarg;
    if (change == 0) {
      svrb2(lnx,r,0xff,"hi depth %u",rp->hidep);
      if (rp->hidep > hidep) { hidep = rp->hidep; hidepr = r; }
    }
  } // each rule

  if (change) return 1;

  for (r = 0; r < rulcnt; r++) {
    rp = rules + r;
    if (rp->ref == rulcnt) continue;

    lno = rp->lno;
    lnx = lno|Lno;
    if (rp->rulrep && rp->argcnt == 0) serror2(lnx,r,0xff,"repeat rule has no args for %.*s",rp->prdnlen[0],rp->prdnam[0]);
  }

  if (hiarg) info("max %u args at ln %u",hiarg,hiargln);
  rp = rules + hidepr;
  sinfo2(rp->lno|Lno,hidepr,0xff,"hi depth %u",hidep);
  hiruldep = hidep;

  return 0;
}

static int rdspec(cchar *fname,ub1 *src)
{
  enum Specstate nxst = Sout,st = Sout;
  enum Ctype t,t2;
  enum Token tk=0,tk2;
  ub2 nt0=0,nt;
  ub2 a,acur=0,scur=0,secur=0,sinc,acnt=0;
  ub2 mrg;
  ub2 ver=0;

  struct rule *rp=nil,*rp2;
  ub1 s,*sp=nil,*sp2;
  ub1 z,repc,idc,*cp=nil,*cp2;
  ub1 *ap=nil;
  ub1 optlvl=0;
  ub1 optpos[16];
  ub1 opos,grpdif;

  enum Specvar sv = Sv_count;
  ub2 c,c2,crep;

  ub2 n = 0,nn;
  ub2 varnam0=0,varnam1=0,varval0=0,varval1,varlen=0;
  ub2 idnlen=0;
  ub2 slen=0;
  ub2 idnam0=0,idnam1=0;
  ub2 ntnam0=0,ntnam1=0,ntlen=0;
  ub2 symnam0=0,symnam1=0,symlen=0;
  ub2 mrgsnam0,mrgsnam1=0,mrgnlen;

  ub2 mp=0,mp0=0;

  bool ucfirst=0;
  bool mapped=0;
  ub1  reptok=0;
  bool isrep0n,isrep1n;
  bool dorng=0;
  ub1  dola=0;
  ub1 doarg;
  bool change;

  ub2 prdid=hi16;

  cchar *mrgnam,*nam;

  ub1 *dsc=nil;
  ub2 dscpos=0;

  char buf[256];
  ub2  pos;

  ub4 lno = 1;

  n = 0;

  do {
    c = src[n];
    if (c == 0) break;
    c2 = src[n+1];

    t = Ctab[c];

    if (t == Cnl) lno++;

  switch (st) {
  case Scount: break;

  case Sout:
    switch (t) {
    case Cws:    break;
    case Cnl:    break;
    case Chsh:   st = Scmt; nxst = Sout; break;
    case Calpha: varnam0 = n; varnam1=0; st = Svarnam; break;
    case Cnum:   serror(n,"expected keyword, found %c",c);
    default:     serror(n,"%s: expected keyword, found %s",fname,chprint(c));
    }
    break;

  case Scmt: if (c == nl) st = nxst; break;

  case Smcmt: if (t == Chsh && c2 == '#') st = nxst; break;

  case Svarnam:
    switch (t) {
    case Calpha: case Cnum: case Cmin: break;
    case Cws:
    case Cnl:    varnam1 = n; break;
    default:     serror(n,"expected <var> <value>, found %c",c);
    }
    if (varnam1 == 0) break;

    varnam1 = n;
    sv = getvar(lno,src,varnam0,varnam1);

    switch (sv) {
    case Sv_count: st = Scmt; break; // unknown
    case Sv_table: st = Srule0; addrules(src,n,lno); break;
    default:       if (t == Cnl) serror(n,"missing value for var %.*s",n-varnam0,src+varnam0);
                   st = Svarnam1;
    }
  break;

  case Svarnam1:
    if (t == Cnl) serror(n,"missing value for %.*s",varnam1-varnam0,src+varnam0);
    else if (t != Cws) { varval0 = n; st = Svarval; }
  break;

  case Svarval:
    if (t == Cnl) {
      varval1 = n;
      while (varval1 > varval0 + 1 && src[varval1] == ' ') varval1--;
      getval(sv,src,varnam0,varnam1-varnam0,varval0,varval1);
      st = Sout;
    }
  break;

  // table
  case Srule0: // start of rule
    switch (t) {
    case Cws:
    case Cnl:    break;
    case Chsh:   st = Scmt; nxst = Srule0; break;
    case Calpha: if (c <= 'Z') serror(n,"initial capital (%c) reserved for terms",c);
                  ntnam0 = n; ntnam1 = 0; st = Srule1; break;
    case Cnum:   serror(n,"expected state name, found %c",c);
    default:     serror(n,"expected state name, found %c",c);
    }
    break;

  case Srule1: // in rule
    switch (t) {
    case Chsh:
    case Cws:
    case Cnl: ntnam1 = n; break;

    case Calpha: case Cnum: break;
    default: serror(n,"rule %.*s: unexpected char '%s' in rule",n-ntnam0,src+ntnam0,chprint(c));
    }
    if (!ntnam1) break;

    ntlen = ntnam1-ntnam0;
    ntnam1 = 0;
    if (ntlen + 1 >= Ntnam) serror(n,"rule name '%.*s' exceeds len %u",Ntnam,src+ntnam0,Ntnam);
    nt0 = getnterm(src,ntnam0,ntlen);
    if (nt0 == nnterm) serror2(n,nt0,0xff,"unknown rule %.*s",ntlen,src+ntnam0);

    rp = rules + nt0;
    if (ntlen > hintnamlen) hintnamlen = ntlen;

    acur = 0;
    dscpos = 0;
    dsc = rp->desc + acur * Dsclen;

    symnam0 = symnam1 = 0;

    if (t == Cnl) st = Spat0; else st = Srule2;
  break;

  case Srule2: // after rule (symbol unused)
    switch (t) {
    case Cws:    break;
    case Chsh:   nxst = Spat0; st = Scmt; break;
    // case Calpha: symnam0 = n; symnam1 = 0; st = Srule3; break;
    case Cnl:    st = Spat0; break;
    default:     serror(n,"expected symbols, found '%s'",chprint(c));
    }
  break;

  case Srule3:
    switch (t) {
    case Calpha: case Cnum: break;
    case Cws: symnam1 = n; st = Srule2; break;
    case Cnl: symnam1 = n; st = Spat0; break;
    default:  serror(n,"expected symbols, found '%s'",chprint(c));
    }
    if (symnam1) {
      symlen = symnam1 - symnam0;
      tk = gettoken(src+symnam0,symlen);
      if (tk == T99_count) serror(n,"unknown token '%.*s'",symlen,src+symnam0);
    }
  break;

  case Spat0: // new rule or next alt
    ver=0;

    switch (t) {
    case Cws:  st = Spat1;   break; // indent = next alt
    case Cnl:                break;
    case Chsh: if (c2 == '#') st = Smcmt;
               else st = Scmt;
               nxst = Spat0; break;

    case Calpha: // new rule
      if (c <= 'Z') serror(n,"initial capital (%c) reserved for terms",c);
      ntnam0 = n; ntnam1 = 0;
      st = Srule1;

      acnt = rp->altcnt;
      if (acnt == 0) serror2(n,nt0,0xff,"rule %s empty",rp->name);

      vrb("add rule %s maxlen %u",rp->name,rp->maxlen);
      break;

    default: serror(n,"expected symbols, found '%s'",chprint(c));
    }
  break;

  case Spat1: // new alt
    if (acur + 1 >= Nalt) serror(n,"exceeding %u alts",acur);

    symnam1 = 0;
    nn = acur * Altlen;
    sp = rp->alts + nn;
    cp = rp->ctls + nn;
    ap = rp->args + nn;

    rp->lnos[acur] = lno;
    dsc = rp->desc + acur * Dsclen;
    dscpos = 0;
    scur = secur = 0;
    optlvl = 0;
    mapped = 0;
    reptok = 0;
    dola=0;
    prdid = hi16;

    switch (t) {
    case Cws:  break;
    case Cnl:  st = Spat0; break;

    case Chsh:
      if (c2 == '#') {
        symnam0 = n+1;
        st = Spat2;
        mapped = 1;
      } else {
        st = Scmt;
        nxst = Spat0;
      }
      break;

    case Cnum:
      ver = ver * 10 + (c - '0');
      break;

    case Calpha:
      if (ver && ver > minver) {
        sinfo(n,"skipping version %u > %u alt",ver,minver);
        st = Scmt;
        nxst = Spat0;
      } else {
        ucfirst = (c >= 'A' && c <= 'Z');
        symnam0 = n;
        st = Spat2;
      }
      break;

    case Cast:
    case Cpls:
      t2 = Ctab[c2];
      if (t2 == Cws || t2 == Cnl) {
        symnam0 = n; st = Spat2;
        mapped = 1;
      } else {
        if (t == Cpls) {
          rp->rulrep = 2;
        } else rp->rulrep = 1;
      }
      break;

    case Cqst:
      t2 = Ctab[c2];

      if (t2 == Cws) { // lookahead
        dola = rp->dolas[acur] = 1;
        lareqs++;
      } else if (t2 == Cnl) { // plain term
        symnam0 = n;
        st = Spat2;
        mapped = 1;
      } else if (t2 == Cqst) { // plain term
        symnam0 = n+1;
        st = Spat2;
        mapped = 1;
      } else if (c2 == '(') { // opt group
        optpos[optlvl] = scur;
        optlvl++;
        n++;
        st = Spat3;
      } else if (c2 == ')') {
        serror(n,"unbalanced group %c",2);
      } else serror(n,"unknown sequence ? %c",c2);
      break;

    default: // mapped symbols
      symnam0 = n;
      st = Spat2;
      mapped = 1;
     break;
    }
  break;

  case Spat2: // in sym
    switch (t) {
    case Calpha: case Cnum: break;
    case Cast:   case Cqst: break;
    case Crdo:   case Crdc: break;
    case Cor:    case Ceq: break;
    case Cws:
    case Cnl:
    case Chsh:   symnam1 = n; break;
    default:     if (mapped == 0 && c != '`' && c != '-' && c != '<' && c != '>' && c != '=')
      serror(n,"rule %s unexpected char '%s' in pattern",ntnam(nt0),chprint(c));
    }
    if (symnam1 == 0) break;

    symlen = symnam1 - symnam0;

    repc = Crep11;
    isrep1n = 0;
    idc = 0;
    sinc = optlvl ? 0 : 1;
    c2 = src[symnam1-1];

    if (symlen > 2 && src[symnam1-2] == '`') { // annotations for args and typedef/id
      switch (c2) {
//     case '>': idc = Cidsc1; break;
//     case '<': idc = Cidsc0; break;
      case '=': idc = Ciddef; break;
      case '~': idc = Cidref; break;
      case '0': ap[scur] = 0x8f; break; // no arg
      case '1': case '2': case '3': case '4': ap[scur] = (c2 - '0') | 0x80;  break; // fixed arg
      default: serror2(n,nt0,0xff,"unknown ctl char '%s'",chprint(c2));
      }
      symlen -= 2;
      if (idc) {
        if (enatidctl) hastidctl = 1;
        else serror2(n,nt0,0xff,"tid ctl '%c' disabled",c);
      }
      c2 = src[symnam0+symlen-1];
    }

    crep = ' '; isrep0n = isrep1n = 0;
    if (symlen > 1) { // annotations for optional and repetition
      crep = c2;
      switch (c2) {
      case '*': repc = Crep0n; sinc = 0; symlen--; isrep0n = 1; break;
      case '?': repc = Crep01; sinc = 0; symlen--; break;
      case '+': repc = Crep11; isrep1n = 1; symlen--; break;
      case ')': crep = ' '; break;
      default:  crep = ' '; break;
      }
    }

    if (scur) dsc[dscpos++] = ' ';

    c2 = src[symnam0];
    tk = T99_count;
    if (symlen > 2 && c2 == '(') { // merge set
      if (mrgcnt + 1 > Mrgcnt) serror(n,"exceeding %u merge sets",mrgcnt);
      if (src[symnam0+symlen-1] != ')') serror(n,"missing ')' in merge set %u",mrgcnt);
      symlen--;

      mp = mp0 = symnam0+1;

      memset(tmpbits,0,T99_count);
      pos = 0;

      mrgsnam0 = mrgsnam1 = 0;
      while (mp < symnam0 + symlen) {
        while (mp < symnam0 + symlen && src[mp] != '|') {
          if (mp > mp0 && src[mp] == '=') break;
          mp++;
        }
        if (mp == mp0) serror(n,"unrecognised merged token '%.*s'",symlen,src+symnam0);
        tk = gettoken(src+mp0,mp-mp0);
        if (tk == T99_count) serror(n,"unknown merged token '%.*s'",mp-mp0,src+mp0);
        if (isrep0n && tk < T0grp) serror2(n,nt0,tk,"repetition '%c' on group 0 token",c2);
        tkrefs[tk] = lno;

        if (tmpbits[tk]) serror(n,"duplicate token %s",tknam(tk));
        tmpbits[tk] = 1;
        if (pos < 8) {
          nam = tknam(tk);
          buf[pos++] = upcase(*nam); buf[pos++] = nam[1];
        }
        if (src[mp] == '=') { // alias
          mp++;
          mrgsnam0 = mp;
          while (mp < symnam0 + symlen && src[mp] != ')') mp++;
          mrgsnam1 = mp++;
          break;
        }
        else mp++;
        mp0 = mp;
      }

      if (mrgsnam1) {
        mrgnlen = mrgsnam1 - mrgsnam0;
        mrgnam = src + mrgsnam0;
      } else {
        mrgnlen = pos;
        mrgnam = buf;
      }

      mrg = addmrg(tmpbits,mrgnam,mrgnlen,lno);

      s = mrg + rulcnt + T99_count;

      dscpos += mysnprintf(dsc,dscpos,Dsclen,"%.32s",mrgnams + mrg * Ntnam);

    } else if (ucfirst || mapped) { // plain term
      tk = gettoken(src+symnam0,symlen);
      if (tk == T99_count) serror2(n,nt0,0xff,"unknown token '%.*s'",symlen,src+symnam0);
      if (isrep0n && tk < T0grp) serror2(n,nt0,tk,"repetition '%c' on group 0 token",c2);

      s = tk;
      tkrefs[tk] = lno;
      dscpos += mysnprintf(dsc,dscpos,Dsclen,"%c%.16s",dola ? '?' : ' ',tknam2(tk,1));
      dola=0;

    // nonterm or merge set
    } else {
      c2 = src[symnam0+symlen-1];
      dscpos += mysnprintf(dsc,dscpos,Dsclen,"%.*s",min(symlen,16),src+symnam0);

      mrg = getmrg(src+symnam0,symlen);
      if (mrg < mrgcnt) {
        s = mrg + T99_count + rulcnt;
        nt = rulcnt;
      } else if (symlen == ntlen && memeq(src+symnam0,rp->name,symlen)) {
        if (secur == 0) serror2(n,nt0,0xff,"left-recursive %.*s",symlen,src+symnam0);
        nt = nt0;
        s = nt + T99_count;
      } else {
        nt = getnterm(src,symnam0,symlen);
        if (nt == nnterm) {
          if (Ctab[c2] == Cnum) { symlen--; } // allow for ( expr1 ; expr2 ..
          nt = getnterm(src,symnam0,symlen);
          if (nt == nnterm) serror2(n,nt0,0xff,"unknown rule '%.*s'",symlen,src+symnam0);
        }
        s = nt + T99_count;
      }
      if (nt < rulcnt) {
        if (repc == Crep0n) serror2(n,nt0,0xff,"repeating nonterm %.*s",symlen,src+symnam0);
        rp2 = rules + nt;
        if (rp2->rulrep && (repc != Crep11 || isrep1n) ) serror2(n,nt0,0xff,"repeat code %c on repeat rule %.*s",crep,symlen,src+symnam0);
        ntrefs[nt] = lno;
      }
    } // nterm or inlined

    sp[scur] = s;

    if (reptok) {
      if (s >= T99_count && s < T99_count + rulcnt) serror2(n,nt0,s,"sym %u: only term repeaters supported",reptok);
      repc = Creplp;
    }

    z = repc | idc;
    if (isrep1n) { //convert x+ into x x*
      sp[scur+1] = sp[scur] = s;
      cp[scur]   |= z;
      cp[scur+1] |= z;
      ap[scur+1] = ap[scur];
      scur += 2;
      secur = 1;
    } else {
      cp[scur] |= z;
      sp[scur++] = s;
      if (sinc) {
        secur += sinc;
      }
    }

    if (scur + 1 >= Altlen) serror2(n,nt0,tk,"alt %u len exceeds %u",acur,Altlen);
    if (scur > rp->maxlen) rp->maxlen = scur;

    if (crep != ' ') dsc[dscpos++] = crep;

    if (t == Cnl || t == Chsh) { // end of alt
      if (optlvl) serror(n,"unbalanced group at pos %u",optpos[optlvl-1]);
      rp->dsclen[acur] = dscpos;
      rp->altlens[acur] = scur;
      rp->prdid[acur] = 0;
      rp->altcnt = ++acur;
    }

    if (t == Cnl) {
      st = Spat0;
    } else if (t == Chsh) {
      st = Scmt;
      nxst = Spat0;
    } else { // next sym
      st = Spat3;
    }
  break;

  case Spat3: // next sym or end of alt

    if (t == Chsh || t == Cnl || t == Cbtk) { // end of alt

      rp->dsclen[acur] = dscpos;
      rp->prdid[acur] = 0;

      if (scur == 0) serror(n,"rule %s empty alt %u",ntnam(nt0),acur);

      for (a = 1; a < acur; a++) { // check dup
        sp2 = rp->alts + a * Altlen;
        slen = rp->altlens[a];
        if (memeq(sp,sp2,min(slen,scur))) serror(n,"rule %s alt %u previously defined at line %u",rp->name,acur,rp->lnos[a]);
      }

      rp->altlens[acur] = scur;
      rp->altcnt = ++acur;
    }

    switch(t) {
    case Cws:  break;
    case Chsh: st = Scmt; nxst = Spat0; break;
    case Cnl:  st = Spat0; break;
    case Cbtk: st = Spat4; break;

    case Cqst:
      t2 = Ctab[c2];
      if (t2 == Cws || t2 == Cnl || t2 == Cqst) { // plain term
        symnam0 = n;
        if (t2 == Cqst) symnam0++;
        symnam1=0;
        st = Spat2;
        mapped = 1;
      } else if (c2 == '(') {
        optpos[optlvl] = scur;
        optlvl++;
        n++;
      } else if (c2 == ')') {
        if (optlvl == 0) serror(n,"unbalanced group %c",c);
        optlvl--;
        opos = optpos[optlvl];
        if (opos >= scur) ice(0,n,"group %u pos %u >= %u",optlvl,opos,scur);
        grpdif = scur - opos;
        if (grpdif > higrpdif) { higrpdif = grpdif; higrpfln = n; }
        if (grpdif > Crep05) serror(n,"group eceeds len %u",grpdif);
        cp[opos] = grpdif << Crepshift;
        n++;
      } else { info("mapped %c",c); symnam0 = n; symnam1 = 0; mapped = 1; st = Spat2; }
    break;

    case Calpha: case Cnum:
      ucfirst = (c >= 'A' && c <= 'Z');
      symnam0 = n; symnam1 = 0; mapped = 0; st = Spat2;
    break;

    case Cpls:
      t2 = Ctab[c2];
      if (t2 != Cws && t2 != Chsh && t2 != Cnl) {
        if (reptok) serror2(n,nt0,0xff,"duplicate repeater, first sym %u",reptok);
        else if (scur == 0) serrfln(FLN,n,nt0,0xff,"repeater at start");
        reptok = scur;
      } else {
        ucfirst = 0;
        symnam0 = n; symnam1 = 0; mapped = 1; st = Spat2;
      }
    break;

    default:
      ucfirst = 0;
      symnam0 = n; symnam1 = 0; mapped = 1; st = Spat2;
    break;
    }
  break;

  case Spat4: // prod name
    switch (t) {
    case Calpha: idnam0 = n; idnam1 = 0; st = Spat5; break;
    case Chsh:   st = Scmt; nxst = Spat0; break;
    default:     serror2(n,nt0,0xff,"unexpected char '%s' in pattern",chprint(c));
    }
  break;

  case Spat5:
    switch (t) {
    case Calpha:
    case Cnum:   break;
    case Cmin:   src[n] = '_'; break;
    case Ceq:    prdid = 0; Fallthrough
    case Cws:
    case Chsh:
    case Cnl:    idnam1 = n; break;
    default:     serror2(n,nt0,0xff,"unexpected char '%s' in pattern",chprint(c));
    }
    if (idnam1 == 0) break;
    idnlen = idnam1 - idnam0;
    rp->prdnam[acur-1] = src + idnam0; rp->prdnlen[acur-1] = idnlen;
    if (t == Cnl) st = Spat0;
    else if (t == Ceq) st = Spat6;
    else { st = Scmt; nxst = Spat0; }
  break;

  case Spat6: // prod id
    switch (t) {
      case Cnum: prdid = prdid * 10 + c - '0'; break;
      case Chsh:
      case Cws: st = Scmt; nxst = Spat0; break;
      case Cnl: st = Spat0; break;
      default:  serror2(n,nt0,0xff,"unexpected char '%s' in pattern",chprint(c));
    }
    if (t != Cnum) {
      rp->prdid[acur-1] = prdid;
    }
  break;

  } // switch

  n++;
  } while (1);

  if (svfpos[Sv_table] == 0) serrorfln(FLN,lno|Lno,"missing table section");

  info("read spec from %s - last changed %s",fname,specmtime);

  showcnt("2rule",rulcnt);
  showcnt("2token",T99_count);
  showcnt("2merge set",mrgcnt);
  showcnt("2lookahead requests",lareqs);

  if (startrnlen) {
    nt = getnterm(startrulnam,0,startrnlen);
    if (nt == rulcnt) serrorfln(FLN,lno|Lno,"start rule '%s' unknown",startrulnam);
  } else nt = 0;

  startrule = nt;
  ntrefs[nt] = rules[nt].lno;

  // if (hastidctl) info("typedef / id ctl active");

#if 1
  for (tk = 0; tk < T99_count; tk++) {
    if (tkrefs[tk] == 0) warning("token %s.%u unreferenced",tknam(tk),tk);
  }
  if (msgerrcnt()) return 1;
#endif

  if (*specdate) snprintf(specxdate,64,"%.32s - %s",specdate,specmtime);
  else strcpy(specxdate,specmtime);

  ub2 dscmax=0,hint=0,hialt=0;

  for (nt = 0; nt < nnterm; nt++) { // check for unreferenced
    rp = rules + nt;
    lno = rp->lno;
    if (lno == 0) serror2(Lno,nt,0xff,"rule %u undefined",nt);
    else if (rp->altcnt == 0) serror2(lno|Lno,nt,0xff,"rule %u empty",nt);
    else if (ntrefs[nt] == 0) {
      if (allowunref) info("rule %s ln %u unreferenced",ntnam(nt),lno);
      else serror2(lno|Lno,nt,0xff,"rule %u unreferenced",nt);
    }
    for (a = 0; a < rp->altcnt; a++) {
      varlen = rp->dsclen[a];
      if (varlen > dscmax) { dscmax = varlen; hint = nt; hialt = a; }
    }
  }
  if (msgerrcnt()) return 1;

  // args
  do {
    change = doargs();
  } while (change);

  rp = rules + hint;
  info("max desc len %u at nterm %u.%u %.*s",dscmax,hint,hialt,rp->dsclen[hialt],rp->desc + hialt * Dsclen);

  return 0;
}

static ub4 poolsizes = 0,latabsizes = 0;

static ub2 lasecmap[Lacnt * T99_count];

#define Prdnam 32
static char prdnams[Vtablen * Prdnam];

static void wrla(struct bufile *fp)
{
  enum Token tk,ts;
  ub2 laid,n,x2,nbit;
  ub1 ve,se;
  ub4 setpos,setcnt;
  ub8 x8,sec,bit,*lasp;
  ub1 secstyp,sectyp = T99_count < 32 ? 4 : 8;
  ub4 pos,blen = 256;
  bool cond;
  char buf[256];

  myfprintf(fp,"#define Lacnt %u\n\n",lacnt);

  myfprintf(fp,"static const ub1 lasetn[%u] = { ",lacnt);
  latabsizes += lacnt;

  for (laid = 0; laid < lacnt; laid++) {
    if (laid) myfputc(fp,',');
    myfprintf(fp,"%u",lasetn[laid]);
  }
  myfputs(fp," };\n\n");

  myfprintf(fp,"#define x 255\nstatic const ub1 lasets[%u] = { ",lacnt * Laset);
  latabsizes += lacnt * Laset;

  pos = 0;
  for (laid = 0; laid < lacnt; laid++) {
    for (n = 0; n < Laset; n++) {
      if (laid || n) { myfputc(fp,','); buf[pos++] = ' '; }
      if (laid && n == 0) { myfputc(fp,' '); buf[pos++] = ' '; }
      ve = lasets[laid * Laset + n];
      if (ve == 255) { myfputc(fp,'x'); buf[pos++] = '.'; }
      else {
        myfprintf(fp,"%2u",ve);
        if (ve < vtablen) pos += mysnprintf(buf,pos,blen,"%2u",vprdmap[ve]);
        else pos += mysnprintf(buf,pos,blen,"> ");
      }
    }
  }
  myfprintf(fp," };\n%-29s%.*s\n#undef x\n\n","//",pos,buf);

  setcnt = 0;
  for (laid = 0; laid < lacnt; laid++) {
    for (tk = 0; tk < T99_count; tk++) {
      lasp = laseconds + (laid * T99_count + tk) * Laset;
      for (n = 0; n < Laset; n++) {
        if (lasp[n]) break;
      }
      if (n < Laset) setcnt++;
    }
  }
  secstyp = setcnt < 256 ? 1 : 2;

  myfprintf(fp,"#define Lasets %u\ntypedef ub%u lasec_t;\n\n",setcnt,sectyp);

  myfprintf(fp,"static const lasec_t laseclst[Lasets * Laset] = { // %u * %u * %u = %u\n",setcnt,sectyp,Laset,setcnt * sectyp * Laset);
  latabsizes += setcnt * sectyp * Laset;

  memset(lasecmap,0xff,sizeof(lasecmap));
  setpos = 0;

  for (laid = 0; laid < lacnt; laid++) {
    for (tk = 0; tk < T99_count; tk++) {
      lasp = laseconds + (laid * T99_count + tk) * Laset;
      for (n = 0; n < Laset; n++) {
        if (lasp[n]) break;
      }
      if (n == Laset) continue;

      lasecmap[laid * T99_count + tk] = setpos;
      myfprintf(fp,"// laid %u tk %s\n  ",laid,tknam(tk)); // nonempty items

      pos = 0;
      for (n = 0; n < Laset; n++) {
        if (setpos || n) myfputc(fp,',');
        sec = lasp[n];
        if (sec == 0) myfputc(fp,'0');
        else if (sec < 10) myfprintf(fp,"%x",(ub4)sec);
        else myfprintf(fp,"0x%lx",sec);
        if (sec == 0) { buf[pos++] = '.'; buf[pos++] = ' '; continue; }
        ve = lasets[laid * Laset + n];
        if (ve < vtablen) se = vprdmap[ve];
        else se = stablen;
        pos += mysnprintf(buf,pos,blen,"se %u ln %u ",se,lasetln[laid * Laset + n]);
        nbit = cntbits8(sec);
        for (ts = 0; ts < T99_count; ts++) {
          bit = 1UL << ts;
          if (nbit * 2 > T99_count) {
            cond = (sec & bit) == 0;
            if (ts == 0) { buf[pos++] = '~'; buf[pos++] = ' '; }
          } else {
            cond = (sec & bit) != 0;
          }
          if (cond) pos += mysnprintf(buf,pos,blen,"%s ",tknam(ts));
        }
      }
      myfprintf(fp," //%.*s\n",pos,buf);
      setpos++;
    }
  }

  myfputs(fp,"\n};\n\n");

  myfprintf(fp,"typedef ub%u lasecs_t;\n#define x %u\n",secstyp,secstyp == 1 ? 255 : hi16);
  myfprintf(fp,"static const lasecs_t lasecmap[Lacnt * T99_count] = { // %u * %u = %u\n  ",lacnt,T99_count,secstyp * lacnt * T99_count);
  latabsizes += secstyp * lacnt * T99_count;

  for (n = 0; n < lacnt * T99_count; n++) {
    if (n) myfputc(fp,',');
    x2 = lasecmap[n];
    if (x2 == hi16) myfputc(fp,'x');
    else myfprintf(fp,"%u",x2);
  }
  myfputs(fp,"\n};\n#undef x\n\n");

  myfprintf(fp,"#if 0\ntypedef ub%u lasec_t;\n",sectyp);

  myfprintf(fp,"static const lasec_t laseconds[Lacnt * T99_count* Laset] = { // %u * %u * %u * %u = %u`B\n",lacnt,T99_count,Laset,sectyp,lacnt * Laset * T99_count * sectyp);

  // latabsizes += lacnt * Laset * T99_count * sectyp;

  for (laid = 0; laid < lacnt; laid++) {
    if (laid) myfprintf(fp,"\n// laid %u\n  ",laid);
    for (tk = 0; tk < T99_count; tk++) {
      lasp = laseconds + (laid * T99_count + tk) * Laset;
      if ( (tk & 7) == 7) myfputs(fp,"\n  ");
      else myfputc(fp,' ');
      for (n = 0; n < Laset; n++) {
        if (laid | tk | n) myfputc(fp,',');
        x8 = lasp[n];
        if (x8 < 10) myfprintf(fp,"%2u",(ub4)x8);
        else myfprintf(fp,"0x%02lx",x8);
      }
    }
  }
  myfputs(fp,"\n};\n#endif\n");

}

static ub4 rultablin(char *buf,ub4 pos,ub4 len,cchar *nam,ub2 wid,bool nocomma)
{
  char buf1[256];
  ub2 pos1;

  if (*nam == '9') { *buf1 = 'x'; pos1 = 1; }
  else if (*nam == '8') { *buf1 = 'X'; pos1 = 1; }
  else pos1 = mysnprintf(buf1,0,256,"P%s",nam);
  if (!nocomma) buf1[pos1++] = ',';

  pos += mysnprintf(buf,pos,len,"%*.*s",-wid-5,pos1,buf1);

  return pos;
}

static ub4 enumln(char *buf,ub4 pos,ub4 len,sb4 wid,cchar *nam,ub2 n,bool last)
{
  ub4 p1;

  if ((n & 3) == 0) p1 = mysnprintf(buf,pos,len,"\n  ");
  else p1 = 0;

  p1 += mysnprintf(buf,pos+p1,len,"P%*s = %2u",wid,nam,n);

  if (last) return p1;

  buf[pos+p1++] = ',';
  return p1;
}

static void wrprd(struct bufile *fp,struct bufile *dfp)
{
  cchar *comma,*anam;
  char *pnam;
  ub1 a,si;
  ub2 atr;
  ub2 ve,se,r,i,r8,pid;
  struct rule *rp;
  struct sentry *ep;
  ub2 n,pn,pos1=0,pos2=0,pos3=0,pos4=0,pos5=0,pos6=0;
  ub2 len,len1=2048,blen=1024;
  static char buf1[2048];
  char buf2[1024];
  char buf3[1024];
  char buf4[1024];
  char buf5[2048];
  char buf6[2048];

  myfputs(fp,"// < tablen = sentry < 1dirtok = argdir < laid = la\n\n");

  for (ve = 0; ve < vtablen; ve++) {
    comma = ve ? "," : "";

    se = vprdmap[ve];
    ep = syntab + se;
    atr = syntabeas[ve];
    si = (atr & Sa_si) >> 4;

    r = ep->nt0;
    rp = rules + r;
    a = ep->alt;
    r8 = r << 8;
    pid = rp->prdid[a];

    // prod name
    pnam = prdnams + ve * Prdnam;
    pn = n = rp->prdnlen[a];
    if (n) memcpy(pnam,rp->prdnam[a],n);
    else {
      n = mysnprintf(pnam,0,Prdnam,"%s",rp->name);
      if (rp->altcnt > 1) n += mysnprintf(pnam,n,Prdnam,"_%u",a);
    }
    if (ep->nve > 1) n += mysnprintf(pnam,n,Prdnam,"_%u",si);

    maxprdnam = max(maxprdnam,n);

    // nampool
    len = mysnprintf(buf1,pos1,len1,"%s ",pnam);
    pos2 += mysnprintf(buf2,pos2,blen,"%s%u",comma,pos1);

    // atrs
    pos3 += mysnprintf(buf3,pos3,blen,atr <= 9 ? "    %3u" : "  0x%03x",atr);
    buf3[pos3++] = ve < vtablen-1 ? ',' : ' ';
    if (atr & ~Sa_len) pos3 += mysnprintf(buf3,pos3,blen," // %s",atrnam(atr));
    buf3[pos3++] = '\n';

    // prdmap
    pos4 += mysnprintf(buf4,pos4,blen,"%s0x%x",comma,se | r8);

    // prd2nod
    if (pos5) {
      pos5 += mysnprintf(buf5,pos5,blen,",\n  ");
      pos6 += mysnprintf(buf6,pos6,blen,",\n  ");
    }
    if (pid == 0) pos5 += mysnprintf(buf5,pos5,len1,"[P%s]%*s = Acount",pnam,n > 12 ? 0 : n - 12," ");
    else {
      if (pid > rp->altcnt) { anam = rp->prdnam[a]; pn = rp->prdnlen[a]; }
      else { anam = rp->prdnam[pid-1]; pn = rp->prdnlen[pid-1]; }
      pos5 += mysnprintf(buf5,pos5,len1,"[P%s]%*s = A%.*s",pnam,n > 12 ? 0 : n - 12," ",pn,anam);
    }

    if (rp->rulrep == 0 || pid == 0) pos6 += mysnprintf(buf6,pos6,len1,"[P%s]%*s = Acount",pnam,n > 12 ? 0 : n - 12," ");
    else {
      if (pid > rp->altcnt) { anam = rp->prdnam[a]; pn = rp->prdnlen[a]; }
      else { anam = rp->prdnam[pid-1]; pn = rp->prdnlen[pid-1]; }
      pos6 += mysnprintf(buf6,pos6,len1,"[P%s]%*s = A%.*slst",pnam,n > 12 ? 0 : n - 12," ",pn,anam);
    }

    pos1 += len;
  }

  myfprintf(dfp,"static char prodnampool[%u] = \n  \"%s\";\n\n",pos1,buf1);
  myfprintf(dfp,"static const ub2 prodnampos[%u] = { %s };\n\n",vtablen,buf2);

  myfprintf(fp,"static const ub2 vprdmap[%u] = { %s }; // rule.se\n\n",vtablen,buf4);

  myfputs(fp,"// nod 1 argc 3 rep.1 s0.1 si.2 len.4 \n");
  myfprintf(fp,"static const ub2 syntabeas[%u] = {\n%.*s};\n\n",vtablen,pos3,buf3);

  // enum
  sb4 pad = -(maxprdnam+2);

  pos1 = 0;
  for (ve = 0; ve < vtablen; ve++) {
    pnam = prdnams + ve * Prdnam;
    pos1 += enumln(buf1,pos1,len1,pad,pnam,ve,0);
  }
  pos1 += enumln(buf1,pos1,len1,pad,"tablen",vtablen,0);

  for (i = 0; i < ndirprd; i++) {
    pnam = dirprdnams + i * Dirprdnam; n = strlen(pnam);
    pos1 += enumln(buf1,pos1,len1,pad,pnam,i + vtablen,0);
    pos5 += mysnprintf(buf5,pos5,len1,",\n  [P%.*s]%*s = Acount",n,pnam,n > 12 ? 0 : n - 12," ");
    pos6 += mysnprintf(buf6,pos6,len1,",\n  [P%s]%*s = Acount",pnam,n > 12 ? 0 : n - 12," ");
  }

  pos1 += enumln(buf1,pos1,len1,pad,"laid",vtablen + ndirprd,0);

  for (i = 0; i < lacnt; i++) {
    pos2 = mysnprintf(buf2,0,32,"laid_%u",i);

    pos1 += enumln(buf1,pos1,len1,pad,buf2,i + vtablen + ndirprd,0);
  }

  pos1 += enumln(buf1,pos1,len1,pad,"endrep",vtablen + ndirprd + lacnt,0);
  pos1 += enumln(buf1,pos1,len1,pad,"count",vtablen + ndirprd + lacnt + 1,1);

  myfprintf(dfp,"enum %sProduction {%.*s\n};\n\n",packed8,pos1,buf1);

  myfprintf(fp,"static enum Astyp prd2nod[Plaid] = {\n  %.*s\n};\n\n",pos5,buf5);
  myfprintf(fp,"static enum Astyp Prd2nod[Plaid] = {\n  %.*s\n};\n\n",pos6,buf6);
}

static void wrfhdr(struct bufile *fp,bool addinfo)
{
  myfprintf(fp,"   generated by gensyn %s %s  @nodiff\n\n",version,fmtdate(globs.prgdtim,globs.prgdmin));
  myfprintf(fp,"   from grammar %s version %s %s lang %s @nodiff */\n\n",specname,specversion,specxdate,speclang);

  if (addinfo) {
    myfprintf(fp,"static const char synfname[] = \"%s\"; // @nodiff\n",specname);
    myfprintf(fp,"static const char syninfo[] = \"%s %s  %s %s\"; // @nodiff\n\n",specname,specversion,specxdate,speclang);
  }
}

static int wrfile(void)
{
  enum Token tk,tk1,tk2,tk3;
  ub2 mrgbit;
  ub2 nt;

  ub2 ndx,len,acnt,cnt;
  ub1 la;
  ub1 laid,lasn;
  ub4 labits;
  ub1 x1;
  ub4 x4;

  cchar *pp,*pp2;
  cchar *nam;

  struct rule *rp;
  struct sentry *ep;
  ub2 se,ve;
  ub2 dircnt=0,vecnt=0;
  ub1 si;
  ub2 *stp;
  ub2 r,nr,a,i;
  ub2 mrg;
  ub2 lno;
  ub4 lnx;
  enum Satrs atr;
  enum Ctl z,repc,idc,*cp;
  ub2 x2;
  ub1 s,*sp;

  enum Ctl argc;

  ub1 typsiz;
  ub2 hinamlen = max(hintnamlen,Tknamlen);
  ub2 prdnamwid;
  ub1 maxlen=0,hise=0;
  ub2 spos=0,sposz=0;
  char spool[Spool];
  ub2 sposs[256];

  ub2 pos1=0,pos2,pos20;
  static char buf1[512];
  char buf2[256];
  char buf3[256];

  hinamlen = max(hinamlen,himrgnamlen);
  if (hinamlen < 6) hinamlen = 6;
  sb2 namwid = -hinamlen;

  static struct bufile sfp;
  static struct bufile dfp;
  ub4 bulen = rulcnt * T99_count * 32 + stablen * Slen * 32 + 0x4000;

  sfp.nam = stabname;
  sfp.dobck = 1;

  myfopen(FLN,&sfp,bulen,1);

  myfprintf(&sfp,"/* %s - LL(1-2) parser tables\n\n",stabname);

  wrfhdr(&sfp,1);

  dfp.nam = sdefname;
  dfp.dobck = 2;

  myfopen(FLN,&dfp,32 * vtablen + 4096,1);

  myfprintf(&dfp,"/* %s - parser defines\n\n",sdefname);

  wrfhdr(&dfp,0);

  memset(sposs,0,sizeof(sposs));
  if (nrulcnt > rulcnt) ice(0,hi32,"nrulcnt %u > %u",nrulcnt,rulcnt);
  myfprintf(&sfp,"enum %sNterm { // %u\n  ",packed8,nrulcnt);
  for (r = 0; r < rulcnt; r++) {
    rp = rules + r;
    if (rp->ref == rulcnt) continue;
    nr = rul2nrul[r];
    len = ntlens[r];
    nam = nterms[r];
    if (spos + len + 2 >= Spool) serror2(rp->lno|Lno,r,0xff,"exceeding %u string pool",Spool);
    memcpy(spool + spos,nam,len);
    sposs[nr] = sposz;
    spos += len;
    sposz += len + 1;
    spool[spos++] = bs;
    spool[spos++] = '0';
    myfprintf(&sfp,"N%*.*s = %2u, %s",namwid,len,nam,nr,(nr & 7) == 7 ? "\n  " : "");
  }
  myfprintf(&sfp,"Ncount = %2u\n};\n\n",nrulcnt);

  myfprintf(&sfp,"static ub2 ntnampos[%u] = { ",nrulcnt);
  for (nr = 0; nr < nrulcnt; nr++) {
    if (nr) myfputc(&sfp,',');
    myfprintf(&sfp,"%u",sposs[nr]);
  }
  myfputs(&sfp," };\n\n");
  poolsizes += nrulcnt * 2;

  myfprintf(&sfp,"static const char ntnampool[%u] = \"%.*s\";\n\n",spos,spos,spool);
  poolsizes += spos;

  myfprintf(&sfp,"enum %sSymbol { // %u\n  ",packed8,mrgcnt + T99_count + nnterm);
  for (tk = 0; tk < T99_count; tk++) {
    myfprintf(&sfp,"S%*s = %2u, %s",namwid,tknam(tk),tk,(tk & 7) == 7 ? "\n  " : "");
  }
  myfprintf(&sfp,"\n  S%*s = %u,\n\n  ",namwid,"token",T99_count);
  for (nt = 0; nt < nnterm; nt++) {
    len = ntlens[nt];
    nam = nterms[nt];
    myfprintf(&sfp,"S%*.*s = %u,%s",namwid,len,nam,nt + T99_count,(nt & 7) == 7 ? "\n  " : " ");
  }
  myfprintf(&sfp,"\n  S%*s = %u,\n\n  ",namwid,"mrgset",T99_count+nnterm);
  for (mrg = 0; mrg < mrgcnt; mrg++) {
    nam = mrgnams + mrg * Ntnam;
    myfprintf(&sfp,"S%*s = %u,%s",namwid,nam,mrg + T99_count + nnterm,(mrg & 7) == 7 ? "\n  " : " ");
  }
  myfprintf(&sfp,"S%*s = %u\n};\n\n",namwid,"count",mrgcnt + T99_count + nnterm);

  typsiz = (mrgcnt < 9 ? 1 : 2);
  myfprintf(&sfp,"typedef ub%u Mrgbits;\n\n",typsiz);
  poolsizes += T99_count * typsiz;

  myfprintf(&sfp,"static Mrgbits tkmrgtab[%u] = { ",T99_count);
  for (tk = 0; tk < T99_count; tk++) {
    if (tk) myfputc(&sfp,',');
    mrgbit = mrgbits[tk];
    myfprintf(&sfp,"%u",mrgbit);
  }
  myfputs(&sfp," };\n\n");

  wrprd(&sfp,&dfp),
  myfclose(&dfp);

  prdnamwid = maxprdnam + 2;

  ub4 sesiz = 2 * Slen;
  ub4 sisiz = (ub4)sizeof(struct seinfo);

  if (hastidctl) {
    myfputs(&sfp,"\n#define Tidctl\n");
  }

  nr = rul2nrul[startrule];
  myfprintf(&sfp,"static const enum Nterm startrule = N%s; // %u\n",ntnam(startrule),nr);
  se = vprdmap[startve];
  myfprintf(&sfp,"static const ub1 startve = %u; // %s\n",startve,prdnams + startve * Prdnam);

  // --- main syntab ---

  myfprintf(&sfp,"#define R0n 0x%x\n",Crep0n);
  myfprintf(&sfp,"#define Rlp 0x%x\n",Creplp);
  myfprintf(&sfp,"#define R01 %u\n",1U << Crepshift);
  for (i = 2; i <= higrpdif; i++) {
    myfprintf(&sfp,"#define R0%u 0x%x\n",i,i << Crepshift);
  }

  if (hastidctl) {
    myfprintf(&sfp,"#define Idf %u\n",Ciddef);
    myfprintf(&sfp,"#define Idr %u\n",Cidref);
  }

  namwid--;

  myfprintf(&sfp,"\nstatic const struct sentry syntab[%u] = { // %u * %u = %u`B\n\n",stablen,stablen,sesiz,stablen * sesiz);

  myfprintf(&sfp,"//  %*s %*s %*s %*s %*s %*s atr\n",namwid,"s0",namwid,"se",namwid,"line",namwid,"alt",namwid,"rule",namwid,"prod");

  for (se = 0; se < stablen; se++) {
    ep = syntab + se;
    lno = ep->lno;
    if (lno == 0) serror(lno|Lno,"stab ndx %u is empty",se);
    len = ep->len;
    if (len == 0) serror(lno|Lno,"stab ndx %u is empty",se);
    if (len > maxlen) { maxlen = len; hise = se; }
  }

  for (se = 0; se < stablen; se++) {
    ep = syntab + se;
    lno = ep->lno;
    len = ep->len;
    a = ep->alt;
    sp = ep->syms;
    cp = ep->ctls;
    nt = ep->nt0;
    rp = rules + nt;
    ve = ep->ve0;
    atr = syntabeas[ve];
    pos2 = mysnprintf(buf2,0,256,"%*s %*u %*u %*u %*s %*s %s",
      namwid,symnam(ep->s0),namwid,se,namwid,lno,namwid,a,namwid,rp->name,namwid,prdnams + ve * Prdnam,atrnam(atr));
    pos2 = underline(buf2,pos2);

    labits = ep->la;
    laid = 0;

    if (labits) pos2 += mysnprintf(buf2,pos2,256," la");
    while (labits && laid < lacnt) {
      if (labits & 1) {
        pos2 += mysnprintf(buf2,pos2,256," %u ",laid);
        for (lasn = 0; lasn < lasetn[laid]; lasn++) {
          la = lasets[laid * Laset + lasn];
          if (la < vtablen) pos2 += mysnprintf(buf2,pos2,256," %s",prdnams + la * Prdnam);
          else {
            tk = dirtks[la - vtablen];
            pos2 += mysnprintf(buf2,pos2,256," ,%s",tknam(tk));
          }
        }
      }
      labits >>= 1; laid++;
    }
    myfprintf(&sfp,"//  %.*s",pos2,buf2);
    myfputs(&sfp,"\n{ { ");

    for (si = 0; si < len; si++) {
      s = sp[si];
      if (si) myfputc(&sfp,',');
      if (s >= nnterm + T99_count) {
        s -= (nnterm + T99_count);
        if (s >= mrgcnt) serror2(lno|Lno,nt,0xff,"invalid mrg set %u",s);
        nam = mrgnams + s * Ntnam;
      }
      else if (s < T99_count) nam = tknam(s);
      else nam = ntnam(s-T99_count);
      myfprintf(&sfp,"S%*s",namwid+1,nam);
    }
    while (si < Slen) { myfprintf(&sfp,",%*u",si < maxlen ? namwid : 0,0); si++; }

    myfputs(&sfp," },\n  { ");

    for (si = 0; si < len; si++) {

      z = cp[si];

      pp = pp2 = nil;

      idc = z & Cidmask;
      repc = z & Crepmask;
      argc = z & Cargmask;

      pos1 = 0;

      switch (idc) {
      case 0: pp = nil; break;
//          case Cidsc0: pp = "Is0"; break;
//          case Cidsc1: pp = "Is1"; break;
      case Ciddef: pp = "Idf"; break;
      case Cidref: pp = "Irf"; break;
      default: serror2(lno|Lno,nt,sp[si],"unknown id ctl %x at pos %u z = %x ",idc,si,z);
      }
      if (pp) pos1 = mysnprintf(buf1,0,256,pp,nil);

      switch(repc) {
      case Crep11: pp = nil;   break;
      case Crep01: pp = "R01"; break;
      case Crep0n: pp = "R0n"; break;
      case Creplp: pp = "Rlp"; break;
      case Crep02: pp = "R02"; break;
      case Crep03: pp = "R03"; break;
      case Crep04: pp = "R04"; break;
      case Crep05: pp = "R05"; break;
      default: serror2(lno|Lno,nt,sp[si],"unknown rep ctl %x",repc);
      }
      if (pp) {
        if (pos1) buf1[pos1++] = '|';
        pos1 += mysnprintf(buf1,pos1,256,pp,nil);
      }
      if (argc) {
        if (pos1) buf1[pos1++] = '|';
        buf1[pos1++] = argc + '0';
      }
      if (pos1 == 0) buf1[pos1++] = '0';

      myfprintf(&sfp,"%*.*s%.*s",namwid,pos1,buf1,si < len - 1,",");
    }
    while (si < Slen) { myfprintf(&sfp,",%*u",si < maxlen ? namwid : 0,0); si++; }

    myfputs(&sfp," }");

    myfprintf(&sfp," }%s\n",se < stablen - 1 ? ",\n" : "");
  }
  myfprintf(&sfp,"};\n\n// max len %u for %u\n#define Syn_maxlen %u\n\n",maxlen,hise,maxlen);

  myfputs(&sfp,"#undef R0n\n#undef Rlp\n#undef R01\n");
  for (i = 1; i <= higrpdif; i++) {
    myfprintf(&sfp,"#undef R0%u\n",i);
  }

  if (hastidctl) myfputs(&sfp,"#undef Is0\n#undef Is1\n#undef Idf\n#undef Irf\n");

  ep = syntab + hise;
  rp = rules + ep->nt0;
  info("max len %u for %u %.*s",maxlen,hise,rp->dsclen[ep->alt],rp->desc + ep->alt * Dsclen);

  // myfprintf(&sfp,"// for diags\nstatic const enum Nterm prodrules[%u] = { %s };\n\n",stablen,buf1);
  poolsizes += stablen;

  // end main syntab

  myfprintf(&sfp,"static const struct seinfo stinfo[%u] = { // %u * %u = %u\n\n",stablen,stablen,sisiz,stablen * sisiz);
  myfprintf(&sfp,"// lno  alt %*s desc\n",namwid,"s0");

  for (se = 0; se < stablen; se++) {
    ep = syntab + se;
    a = ep->alt;
    rp = rules + ep->nt0;
    s = ep->s0;

    if (s >= nnterm + T99_count) {
      s -= (nnterm + T99_count);
      nam = mrgnams + s * Ntnam;
    }
    else if (s < T99_count) nam = tknam(s);
    else nam = ntnam(s-T99_count);

    len = min(rp->dsclen[a],64);
    poolsizes += len;
    pos1 = mysnprintf(buf1,0,256,"\"%.*s\"",len,rp->desc + a * Dsclen);

    myfprintf(&sfp," { %3u, %2u, S%*s, %-32.*s }",ep->lno,ep->alt,namwid,nam,pos1,buf1);
    myfputc(&sfp,se < stablen-1 ? ',' : ' ');
    myfprintf(&sfp," // %2u %s\n",se,rp->name);
  }
  myfputs(&sfp,"};\n\n");

  if (lacnt) wrla(&sfp);

  if (mrgcnt) {
    myfputs(&sfp,"/* mrg sets\n");

    for (mrg = 0; mrg < mrgcnt; mrg++) {
      mrgbit = 1U << mrg;
      myfprintf(&sfp,"\n %2u  %*ss ",mrg,-himrgnamlen,mrgnams + mrg * Ntnam);
      for (tk = 0; tk < T99_count; tk++) {
        if (mrgbits[tk] & mrgbit) myfprintf(&sfp," %s",tknam(tk));
      }
      myfprintf(&sfp,"  ln %u",mrglnos[mrg]);
    }
    myfputs(&sfp,"\n*/\n\n");
  }

  // prdsel
  char comma;

  ub2 ntok = T99_count;

  ub2 ntok2 = expndx(ntok,ntok >> 2);

  myfputs(&sfp,"#define x Pcount\n");
  myfputs(&sfp,"#define X Pendrep\n");
  myfprintf(&sfp,"#define Stbl_tklen %u\n",ntok2);
  if (ntok2 != ntok) myfprintf(&sfp,"// from %u\n",ntok);

  myfprintf(&sfp,"\nstatic const enum Production prdsel[Ncount * Stbl_tklen] = { // %u * %u = %u",nrulcnt,ntok2,nrulcnt * ntok2);

  sb2 prdnamwid2 = -(prdnamwid);

  for (r = 0; r < rulcnt; r++) {
    rp = rules + r;
    if (rp->ref == rulcnt) continue;

    nr = rul2nrul[r];
    lno = rp->lno;
    lnx = lno|Lno;

    ndx = (ub2)nr * T99_count;
    stp = prdsel + ndx;

    myfprintf(&sfp,"\n// ------ line %3u %s ------\n",lno,ntnam(r));

    pos1 = pos2 = pos20 = 0;
    cnt = 0;
    for (tk = 0; tk < ntok2; tk++) {
      comma = (r == rulcnt - 1 && tk == ntok2 - 1);

      if (tk >= T99_count) { // fill aligned table
        pos1 = rultablin(buf1,pos1,256,"9",prdnamwid,comma);
//        pos2 += mysnprintf(buf2,pos2,256,"  %*s   ",prdnamwid2,"n/a");
      } else {
        x2 = stp[tk];
        if (x2 == Invpos) {
          pos1 = rultablin(buf1,pos1,256,"9",prdnamwid,comma);
          pos2 += mysnprintf(buf2,pos2,256,"    %*s",prdnamwid2,".");
        } else if (x2 == Repout) {
          pos1 = rultablin(buf1,pos1,256,"8",prdnamwid,comma);
          pos2 += mysnprintf(buf2,pos2,256,"    %*s",prdnamwid2,".");
        } else if (x2 >= vtablen + ndirprd + lacnt) serror2(lnx,r,tk,"invalid prodsel %u >= %u+%u+%u = %u",x2,vtablen,ndirprd,lacnt,vtablen + ndirprd + lacnt);

        else if (x2 >= vtablen + ndirprd) { // lookahead
          laid = x2 - (vtablen + ndirprd);
          mysnprintf(buf3,0,256,"laid_%u",laid);
          pos1 = rultablin(buf1,pos1,256,buf3,prdnamwid,comma);
          pos2 += mysnprintf(buf2,pos2,256,"   %u?%*s",laid,prdnamwid2,tknam(tk));
          cnt++;

        } else if (x2 >= vtablen) { // directs
          x2 -= vtablen;
          tk2 = dirtks[x2];
          if (tk != tk2) svrb2(lnx,r,tk,"dirtok %s vs %s for %u",tknam(tk2),tknam(tk),x2);
          x1 = rp->firstrn[tk];
          pos1 = rultablin(buf1,pos1,256,dirprdnams + x2 * Dirprdnam,prdnamwid,comma);
          pos2 += mysnprintf(buf2,pos2,256,"   %u,%*s",x1,prdnamwid2,tknam(tk));
          cnt++; dircnt++;

        } else { // regular
          se = vprdmap[x2];
          atr = syntabeas[x2];
          ep = syntab + se;
          si = (atr & Sa_si) >> 4;
          nam = prdnams + x2 * Prdnam;
          pos1 = rultablin(buf1,pos1,256,nam,prdnamwid,comma);
//          buf2[pos2++] = ep->la ? '?' : ' ';
          pos2 += mysnprintf(buf2,pos2,256,"%2u %c%*s",x2,si ? si + '0' : ' ',prdnamwid2,tknam(tk));
          cnt++; vecnt++;
       }
      }
      if ( (tk & 3) == 3 || tk == ntok2 - 1) {
        myfprintf(&sfp,"  %s",buf1);
        if (cnt) myfprintf(&sfp," // %.*s",pos2,buf2);
        myfputc(&sfp,'\n');
        pos1 = pos2 = 0;
        cnt = 0;
      }
    }
  }
  if (pos1) myfputc(&sfp,'\n');
  myfputs(&sfp,"};\n\n");

  myfputs(&sfp,"#undef x\n#undef X\n\n");

  myfprintf(&sfp,"// %2u ve entries",vecnt);
  if (dircnt) myfprintf(&sfp," %2u dir entries",dircnt);

  myfprintf(&sfp,"\n\nstatic const ub1 hiruldep = %u;\n",hiruldep);

  myfprintf(&sfp,"\n\nstatic const ub2 poolsizes = %u;\n",poolsizes);
  if (latabsizes) myfprintf(&sfp,"#define Latabsizes %u\n\n",latabsizes);

  x4 = stablen * (sesiz + sisiz) + nrulcnt * ntok2 + latabsizes + poolsizes;

  info("table sizes: prods %u + sel %u + la %u + pool %u sum %u`B",stablen * (sesiz + sisiz),nrulcnt * ntok2,latabsizes,poolsizes,x4);

  if (do_transcript == 0) return myfclose(&sfp);

  myfputs(&sfp,"#if 0\n\n--- transcript of parsed spec ---\n\n");

  for (r = 0; r < nnterm; r++) {
    rp = rules + r;

    myfprintf(&sfp,"%.*s%3u %s",r,"\n",rp->lno,ntnam(r));
    acnt = rp->altcnt;
    for (a = 0; a < acnt; a++) {
      myfprintf(&sfp,"\n%3u   ",rp->lnos[a]);
      if (rp->rulrep) myfputc(&sfp,rp->rulrep == 1 ? '*' : '+');
      myfwrite(&sfp,rp->desc + a * Dsclen,rp->dsclen[a]);
      if (rp->prdnlen[a]) myfprintf(&sfp,"\t %.*s\n",rp->prdnlen[a],rp->prdnam[a]);
    }
  }

  myfputs(&sfp,"\n#endif\n");

  return myfclose(&sfp);
}

enum Cmdopt { Co_until=1,Co_uncond,Co_Winfo };

static struct cmdopt cmdopts[] = {
//  { "trace",'t',Co_trace,"?%ulevel","enable tracing" },
//  { "Winfo",' ',Co_Winfo,"list","comma-separated list of diags to report as info" },
  { "",'u',      Co_uncond, "",         "unconditional write" },
  { "until", ' ',Co_until, "%espec,gen,out", "process until <pass>" },
  { nil,3,0,"<spec> <syntab> <syndef>","gensyn"}
};

static int cmdline(int argc, char *argv[])
{
  ub4 orgargc = (ub4)argc;
  struct cmdval coval;
  struct cmdopt *op;
  enum Parsearg pa;
  cchar *prgnam;
  bool havereg,endopt;

  if (argc > 0) {
    prgnam = strrchr(argv[0],'/');
    if (prgnam) prgnam++; else prgnam = argv[0];
    argc--; argv++;
  } else prgnam = "gensyn";

  globs.prgnam = prgnam;
  globs.msglvl = Info;
  globs.rununtil = 0xff;

  iniutil();
  iniprgtim();

  while (argc) { // options
    havereg = 0;
    endopt = 0;
    pa = parseargs((ub4)argc,argv,cmdopts,&coval,nil,1);

    switch (pa) {
    case Pa_nil:
    case Pa_eof: endopt = 1; break;

    case Pa_min2: endopt = 1; break;

    case Pa_min1:
    case Pa_plusmin:
    case Pa_plus1: havereg = 1; break;

    case Pa_regarg: havereg = 1; break; // first non-option regular

    case Pa_notfound:
      error("option '%.*s' at arg %u not found",coval.olen,*argv,orgargc - (ub4)argc);
      return 1;

    case Pa_noarg:
      error("option '%.*s' missing arg",coval.olen,*argv);
      return 1;

    case Pa_found:
    case Pa_genfound:
      if (coval.err) { error("option '%.*s' invalid arg %u",coval.olen,*argv,coval.err); return 1; }
      argc--; argv++;
      break;
    case Pa_found2:
    case Pa_genfound2:
      if (coval.err) { error("option '%.*s' invalid arg %u",coval.olen,*argv,coval.err); return 1; }
      argc -=2; argv += 2;
      break;
    }

    if (havereg) break;
    else if (endopt) { argc--; argv++; break; }

    op = coval.op;

    switch(op->opt) {
    case Co_help: return 1;
    case Co_version: return 1;
    case Co_license: return 1;
    case Co_until: globs.rununtil = coval.uval; break;
//    case Co_Winfo: diaset(Info,(cchar *)coval.sval); break;
//    case Co_trace: trclvl = coval.uval; diaset(Vrb,(cchar *)coval.sval); break;
    }
    if (coval.err) return 1;
  }

  while (argc) { // regular args
    if (!specname) specname = (cchar *)*argv;
    else if (!stabname) stabname = (cchar *)*argv;
    else if (!sdefname) sdefname = (cchar *)*argv;
    else warning("ignoring extra arg '%s'",*argv);
    argc--; argv++;
  }

  setmsglvl(globs.msglvl,msgopts);
  return 0;
}

static void init(void)
{
  setsigs();

  inios();
  globs.maxvm = 1;
  oslimits();
  inimem();
  inimsg(msgopts);
}

void bugreport(cchar *rep,ub2 rlen,cchar *tag) {}

static int do_main(int argc, char *argv[])
{
  int rv = 1;

  struct myfile specfile;
  struct fnaminf *fb;

  ub1 *spec;
  ub4 len,lncnt;
  ub4 *lntab;

  ub8 T0=0,T1;

  timeit(&T0,nil);
  T1 = T0;

  rv = cmdline(argc,argv);
  if (rv) return 1;
  else if (!specname) { errorfln(FLN,0,"missing spec file"); return 1; }
  else if (!stabname) { errorfln(FLN,0,"missing syn tab file"); return 1; }
  else if (!sdefname) { errorfln(FLN,0,"missing syn def file"); return 1; }

  sassert(sizeof(enum Token) == 1,"short enums required");
  sassert(sizeof(ub8) == 8,"expect long long to be 8 bytes");

//  if (sizeof(ub8) != 8) return error("expect long long to be 8 bytes, %u",(ub4)sizeof(ub8));

  if (readfile_pad(&specfile,specname,1,hi24,4,0)) return 1;
  spec = specfile.buf;
  len = specfile.len;
  if (len == 0) { error("%s is empty",specname); return 1; }
  specdmin = (ub4)(specfile.mtime / 60);
  specdtim = nixday2cal(specdmin / (24 * 60));
  specmtime = fmtdate(specdtim,specdmin);

//  fb = getsrcmfile();
//  fb->path = specname;
//  fb->len = len;

  lntab = mklntab(spec,len,&lncnt);
  // setsrcmfile(fb,lntab,lncnt,len);

  if (rdspec(specname,spec)) return 2;
  if (globs.rununtil < 1) { info("until %u", globs.rununtil); return 0; }

//  while (optrules()) ;

  timeit(&T1,"read spec in ");

  if (mkfirstsec()) return 2;

  timeit(&T1,"calculated first and second sets in");

  if (mktables()) return 2;
  if (globs.rununtil < 2) { info("until %u", globs.rununtil); return 0; }

  timeit(&T1,"made tables in");

  if (wrfile()) return 2;
  info("wrote %s",stabname);

  timeit(&T1,"wrote syntab in");

  timeit(&T0,"parsing table generation took");

  return 0;
}

int main(int argc, char *argv[])
{
  int rv;

  sassert(T99_count <= 64,"expect u64 token bits");
  sassert(Nalt <= 32,"expect u32 alt bits");
  sassert(Slen < 16,"expect 4 slen bits");
  sassert(Mrgcnt <= 16,"expect u16 mrg bits");

  init();

  rv = do_main(argc,argv);

  if (rv > 1) warning("%s exiting with error",globs.prgnam);
  eximsg();
  eximem(rv == 0);
  exios(rv == 0);

  return rv || globs.retval;
}
