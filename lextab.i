/* lextab.i - lexer core, pass 1

   generated by genlex 0.1.0-alpha  3 Oct 2022  5:12

   from lua.lex 0.1.0  3 Oct 2022  5:14 lua
   options: code yes  tokens yes
 */
#define UU 0  //  ' _'
#define AF 1  //  ' ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
#define N0 2  //  ' 0'
#define NM 3  //  ' 123456789'
#define HT 4  //  ' \t '
#define VT 5  //  ' \f '
#define CR 6  //  ' \r '
#define NL 7  //  ' \n '
#define HS 8  //  ' # '
#define QQ 9  //  ' " ' '
#define CO 10 //  ' { '
#define RO 11 //  ' ( '
#define SO 12 //  ' [ '
#define CC 13 //  ' } '
#define RC 14 //  ' ) '
#define SC 15 //  ' ] '
#define AO 16 //  ' < '
#define AC 17 //  ' > '
#define CL 18 //  ' : '
#define SM 19 //  ' ; '
#define CA 20 //  ' , '
#define DT 21 //  ' . '
#define EQ 22 //  ' = '
#define PM 23 //  ' + - '
#define O1 24 //  ' % & * / @ ^ | ~ '
#define O2 25 //  ' ! '
#define EOF 26 //  ' \0 '
#define AN 1  // + ' 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'
#define NU 2  // + ' 0123456789'
#define HX 64 // + ' ABCDEFabcdef'
#define WS 0  // - '   '


  void *compgo1_root[28] = {
  &&lx_u1,	// t=uu uu
  &&lx_id1_Caf_0,	// t=af af
  &&lx_znlit0,	// t=n0 n0
  &&lx_nlit1_Cnm_0,	// t=nm nm
  &&lx_root,	// t=ht ht
  &&lx_root,	// t=vt vt
  &&lx_root,	// t=cr cr
  &&lx_root_Cnl_0,	// t=nl nl
  &&lx_cmt0,	// t=hs hs
  &&lx_slit0_Cqq_0,	// t=qq qq
  &&lx_root_gentk_0,	// t=co co tk co
  &&lx_root_gentk_0,	// t=ro ro tk ro
  &&lx_root_gentk_0,	// t=so so tk so
  &&lx_root_gentk_0,	// t=cc cc tk cc
  &&lx_root_gentk_0,	// t=rc rc tk rc
  &&lx_root_gentk_0,	// t=sc sc tk sc
  &&lx_ao1,	// t=ao ao
  &&lx_ac1,	// t=ac ac
  &&lx_col1,	// t=cl cl
  &&lx_root_gentk_0,	// t=sm sm tk sepa
  &&lx_root_gentk_0,	// t=ca ca tk comma
  &&lx_dot,	// t=dt dt
  &&lx_eq1,	// t=eq eq
  &&lx_pm_Cpm_0,	// t=pm pm
  &&lx_op11_Co1_0,	// t=o1 o1
  &&lx_op21_Co2_0,	// t=o2 o2
  &&lx_eof,	// t=EOF EOF
  
  &&lxer_root_28_1};	// ln 547


  ub1 tktab_root[21] = { T99_count,T99_count,T99_count,T99_count,T99_count,T99_count,T99_count,T99_count,T99_count,T99_count,Tco,Tro,Tso,Tcc,Trc,Tsc,T99_count,T99_count,T99_count,Tsepa,Tcomma };

 
// N  c 1  t 27  u 0
lx_root_tk:
  dfp0 = N - prvN;
  dfp1 = n - prvn;
  prvN = N;
  prvn = n;
  if (dfp0 > 1) {
    tk |= 0x80;
    if (dfp0 < 0x80) dfp0s[fn0++] = dfp0;
    else { dfp0s[fn0++] = dfp0 & 0x80; dfp0s[fn0++] = dfp0 >> 7; dfp0s[fn0++] = dfp0 >> 15; }
  }
  if (dfp1 > 1) {
    tk |= 0x40;
    if (dfp1 < 0x80) dfp1s[fn1++] = dfp1;
    else { dfp1s[fn1++] = dfp1 & 0x80; dfp1s[fn1++] = dfp1 >> 7; dfp1s[fn1++] = dfp1 >> 15; }
  }
  tks[dn] = tk;
  

lx_root:
  
  while (sp[n] == ' ') n++; // 32 
  N = n; c = sp[n++];

   t = ctab[c];  goto *compgo1_root[t];
  
lx_root_Cnl_0: // from root.nl set 7 ctl 1
// donl
lntab[l] = n;
  // sinfo(n,"ln %u n %u",l,n);
  l++;
  nlcol = n;
  
 
  goto lx_root;

lx_pm_Cpm_0: // from root.pm set 23 ctl 1
atrs[an++] = c;   goto lx_pm;

lx_nlit1_Cnm_0: // from root.nm set 3 ctl 1
ipart4 = c - '0';   goto lx_nlit1;

lx_id1_Caf_0: // from root.af set 1 ctl 1
prvc1 = c;   goto lx_id1;

lx_slit0_Cqq_0: // from root.qq set 9 ctl 1
Q=c;   goto lx_slit0;

lx_op11_Co1_0: // from root.o1 set 24 ctl 1
atrs[an++] = c;   goto lx_op11;

lx_op21_Co2_0: // from root.o2 set 25 ctl 1
atrs[an++] = c;   goto lx_op21;

lx_root_gentk_0:
  tk = tktab_root[t]; goto lx_root_tk;


//   c 0  t 1  u 0
lx_eq1:
  
  c = sp[n];
      if (c == '='  ) { n++; atrs[an++] = '='; 
tk = Top; goto lx_root_tk; // csw
} else  { tk = Tdas; goto lx_root_tk; // csw
}  

//   c 0  t 1  u 0
lx_col1:
  
  c = sp[n];
      if (c == ':'  ) { n++; tk = Tdcol; goto lx_root_tk; // csw
} else  { tk = Tcolon; goto lx_root_tk; // csw
}  

//   c 1  t 3  u 0
lx_dot:
  
  c = sp[n];
      if ( (t = ctab[c]) == DT &&  sp[n+1] == '.') { n += 2; tk = Tell; goto lx_root_tk; // csw
}  else if (t == DT   ) { n++; tk = Top; goto lx_root_tk; // csw
}  else if (t == N0   ) { n++; goto lx_flitf0; // csw
}  else if (t == NM   ) { n++; goto lx_flitf; // csw
} else  { tk = Tdot; goto lx_root_tk; // csw
}  

//   c 1  t 2  u 0
lx_ao1:
  
  c = sp[n];
      if ( (t = ctab[c]) == EQ) { n++; tk = Taas; goto lx_root_tk; // csw
}  else if (t == AO    &&  sp[n+1] == '=') { n += 2; tk = Taas; goto lx_root_tk; // csw
}  else if (t == AO   ) { n++; tk = Top; goto lx_root_tk; // csw
} else  { tk = Tao; goto lx_root_tk; // csw
}  

//   c 1  t 2  u 0
lx_ac1:
  
  c = sp[n];
      if ( (t = ctab[c]) == EQ) { n++; tk = Taas; goto lx_root_tk; // csw
}  else if (t == AC    &&  sp[n+1] == '=') { n += 2; tk = Taas; goto lx_root_tk; // csw
}  else if (t == AC   ) { n++; tk = Top; goto lx_root_tk; // csw
} else  { tk = Tac; goto lx_root_tk; // csw
}  

//   c 1  t 1  u 0
lx_op11:
  
  c = sp[n];
      if (c == Q    ) { n++; goto lx_op12; // csw
}  else if (c == '='  ) { n++; tk = Taas; goto lx_root_tk; // csw
} else  { tk = Top; goto lx_root_tk; // csw
}  

//   c 0  t 1  u 0
lx_op12:
  
  c = sp[n];
      if (c == '='  ) { n++; tk = Taas; goto lx_root_tk; // csw
} else  { tk = Top; goto lx_root_tk; // csw
}  

//   c 1  t 1  u 0
lx_op21:
  
  c = sp[n];
      if (c == '='  ) { n++; tk = Top; goto lx_root_tk; // csw
}  else if (c == Q    ) { n++; goto lx_op22; // csw
} else  { tk = Top; goto lx_root_tk; // csw
}  

//   c 0  t 1  u 0
lx_op22:
  
  c = sp[n];
      if (c == '='  ) { n++; tk = Taas; goto lx_root_tk; // csw
} else  { tk = Top; goto lx_root_tk; // csw
}  

//   c 0  t 0  u 0
lx_cmt0:
  
       { cmt0 = N; 
goto lx_cmt; // csw
}  

//   c 1  t 0  u 0
lx_cmt:
  
  c = sp[n++];
      if (c == '\n' ) { 
  cmtcnt++;
// donl
lntab[l] = n;
  // sinfo(n,"ln %u n %u",l,n);
  l++;
  nlcol = n;
  
 

goto lx_root; // csw
} else  { goto lx_cmt; // csw
}  

//   c 0  t 1  u 1
lx_u1:
  
  c = sp[n];
      if (c == '_'  ) { n++; N=n; 
goto lx_dun0; // csw
}  else if ( (utab[c] & AN) ) { n++; goto lx_id2; // csw
} else  { id1cnt++; atrs[an++] = id1getadd('_') | La_id1; 
tk = Tid; goto lx_root_tk; // csw
}  

//   c 0  t 0  u 1
lx_dun0:
  
  c = sp[n];
      if ( (utab[c] & AN) ) { n++; goto lx_dun1; // csw
} else  { 
  prvc1 = prvc2 = '_';
// id2u
id2cnt++;
  // info("add id.2  %s%s",chprint(prvc1),chprint(prvc2));
  if (prvc1 < id2loch1) id2loch1 = prvc1;
   else if (prvc1 > id2hich1) id2hich1 = prvc1;
  tk = Tid;
  an++;
  
 

goto lx_root; // csw
}  

//   c 0  t 0  u 1
lx_dun1:
  
  c = sp[n];
      if ( (utab[c] & AN) ) { n++; goto lx_dun; // csw
} else  { 
  // dunder2
id2cnt++;
  an++;
  // info("add id.%-2u __%.*s",len,len,chprintn(sp+N,len));
  
 

goto lx_root; // csw
}  

//   c 0  t 0  u 1
lx_dun:
  
  c = sp[n];
      if ( (utab[c] & AN) ) { n++; goto lx_dun; // csw
} else  { 
  // dunder
idcnt++;
  len = n - N;
  // info("add id.%-2u __%.*s",len,len,chprintn(sp+N,len));
  len2 = len - 2;
  if (len2 == 2) dun = lookupdun2(sp[N],sp[N+1]);
  else dun = lookupdun(sp+N,len2);
  if (dun < D99_count) atrs[dn] = dun | La_iddun;
  else {
    x4 = mapgetadd(&idtab,sp+N,len2,hc);
    if (x4 < La_idprv) atr = x4;
    else {
      bits[bn++] = x4 | ((ub8)dn << 32); atr = La_id4;
    }
  }
  
 

goto lx_root; // csw
}  

//   c 0  t 0  u 1
lx_id1:
  
  c = sp[n];
      if ( (utab[c] & AN) ) { n++; goto lx_id2; // csw
} else  { 
  id1cnt++; atrs[an++] = id1getadd(prvc1) | La_id1; 

tk = Tid; goto lx_root_tk; // csw
}  

//   c 0  t 0  u 1
lx_id2:
  
  c = sp[n];
      if ( (utab[c] & AN) ) { n++; goto lx_id; // csw
} else  { 
  prvc1 = sp[n-2]; prvc2 = sp[n-1];
// id2
// info("add id.2  %s%s",chprint(prvc1),chprint(prvc2));
  if (prvc1 == 'o' && prvc2 == 'r') {
    tk = Top; atrs[an++] = '|';
  }
  else if ( (kw = lookupkw2(prvc1,prvc2)) < t99_count) tk = kw;
  else if ( (blt = lookupblt2(prvc1,prvc2)) < B99_count) { tk = id; atrs[an++] = blt | La_idblt; bltcnt++; }
  else {
    id2cnt++;
    if (prvc1 < id2loch1) id2loch1 = prvc1;
    else if (prvc1 > id2hich1) id2hich1 = prvc1;
    tk = Tid;
    an++;
  }
  
 

tk = Tid; goto lx_root_tk; // csw
}  

//   c 0  t 0  u 1
lx_id:
  
  c = sp[n];
      if ( (utab[c] & AN) ) { n++; goto lx_id; // csw
} else  { 
  // id
len = n - N;
  len2 = len;
  if (len == 3 && sp[N] == 'a' && sp[N] == 'n' && sp[N] == 'd') {
    tk = Top;
    atrs[an++] = '&';
  } else {
    hc = hashstr(sp+N,len2,Hshseed);
    tk = Tid;
    kw = lookupkw(sp+N,len2,hc);
    if (kw < t99_count) {
      atr = kw; if (kw < (enum token)T99_mrg) tk = kw; else tk = kwhshmap[kw];
    } else {
      tk = Tid;
      blt = lookupblt(sp+N,len2,hc);
      if (blt < B99_count) { atr = blt | La_idblt; bltcnt++; }
      else {
        x4 = mapgetadd(&idtab,sp+N,len2,hc);
        if (x4 < La_idprv) atr = x4;
        else {
          bits[bn++] = x4 | ((ub8)dn << 32); atr = La_id4;
       }
     }
   }
  } // id
  
 

goto lx_root; // csw
}  

//   c 0  t 2  u 0
lx_pm:
  
  c = sp[n];
      if ( (t = ctab[c]) == PM) { n++; goto lx_pm; // csw
}  else if (t == EQ   ) { n++; tk = Taas; goto lx_root_tk; // csw
} else  { tk = Top; goto lx_root_tk; // csw
}  

//   c 4  t 4  u 0
lx_znlit0:
  
  c = sp[n];
      if ((c | 0x20) == 'b') { n++; goto lx_ilitb0; // csw
}  else if ((c | 0x20) == 'x') { n++; goto lx_ilitx0; // csw
}  else if ( (t = ctab[c]) == UU) { n++; goto lx_znlit0; // csw
}  else if (t == N0   ) { n++; goto lx_nlit0; // csw
}  else if (t == NM   ) { n++; ipart4 = c - '0';  
goto lx_nlit1; // csw
}  else if (t == DT   ) { n++; goto lx_flitf0; // csw
}  else if ((c | 0x20) == 'e') { n++; goto lx_nlite0; // csw
}  else if (c == 'j'  ) { n++; ctls[cn++] = Lan_im;  
tk = Tnlit; goto lx_root_tk; // csw
} else  { ctls[cn++] = 0;  
tk = Tnlit; goto lx_root_tk; // csw
}  

//   c 2  t 4  u 0
lx_nlit0:
  
  c = sp[n];
      if ( (t = ctab[c]) == UU) { n++; goto lx_nlit0; // csw
}  else if (t == N0   ) { n++; goto lx_nlit0; // csw
}  else if (t == NM   ) { n++; ipart4 = c - '0';  
goto lx_nlit1; // csw
}  else if (t == DT   ) { n++; goto lx_flitf0; // csw
}  else if ((c | 0x20) == 'e') { n++; goto lx_nlite0; // csw
}  else if (c == 'j'  ) { n++; ctls[cn++] = Lan_im;  
tk = Tnlit; goto lx_root_tk; // csw
} else  { ctls[cn++] = 0;  
tk = Tnlit; goto lx_root_tk; // csw
}  

//   c 2  t 4  u 0
lx_nlit1:
  
  c = sp[n];
      if ( (t = ctab[c]) == N0) { n++; ipart4 *= 10; 
goto lx_nlit; // csw
}  else if (t == NM   ) { n++; ipart4 = ipart4 * 10 + (c - '0'); 
goto lx_nlit; // csw
}  else if (t == DT   ) { n++; goto lx_flitf0; // csw
}  else if ((c | 0x20) == 'e') { n++; goto lx_flitxs; // csw
}  else if (t == UU   ) { n++; goto lx_nlit1; // csw
}  else if (c == 'j'  ) { n++; ctls[cn++] = (ub1)ipart4 | Lan_im;  
tk = Tnlit; goto lx_root_tk; // csw
} else  { ctls[cn++] = ipart4;  
tk = Tnlit; goto lx_root_tk; // csw
}  

// nlit 3+ int digits  c 2  t 4  u 0
lx_nlit:
  
  c = sp[n];
      if ( (t = ctab[c]) == N0) { n++; goto lx_nlit; // csw
}  else if (t == NM   ) { n++; goto lx_nlit; // csw
}  else if (t == DT   ) { n++; goto lx_flitf0; // csw
}  else if ((c | 0x20) == 'e') { n++; goto lx_flitxs; // csw
}  else if (t == UU   ) { n++; goto lx_nlit; // csw
}  else if (c == 'j'  ) { n++; ctls[cn++] = Lan_a | Lan_im; 
tk = Tnlit; goto lx_root_tk; // csw
} else  { ctls[cn++] = Lan_a; 
tk = Tnlit; goto lx_root_tk; // csw
}  

// start of flit fraction  c 2  t 2  u 0
lx_flitf0:
  
  c = sp[n];
      if ( (t = ctab[c]) == N0) { n++; goto lx_flitf0; // csw
}  else if (t == NM   ) { n++; ctls[cn] = min(n-N,15) | Lan_a; 
goto lx_flitf; // csw
}  else if ((c | 0x20) == 'e') { n++; goto lx_flitxs; // csw
}  else if (c == 'j'  ) { n++; ctls[cn++] = Lan_a | Lan_im; 
tk = Tnlit; goto lx_root_tk; // csw
} else  { ctls[cn++] = Lan_a; 
tk = Tnlit; goto lx_root_tk; // csw
}  

// flit fraction digits  c 2  t 1  u 1
lx_flitf:
  
  c = sp[n];
      if ( (utab[c] & NU) ) { n++; goto lx_flitf; // csw
}  else if (c == '_'  ) { n++; goto lx_flitf; // csw
}  else if ((c | 0x20) == 'e') { n++; goto lx_flitxs; // csw
}  else if (c == 'j'  ) { n++; ctls[cn++] |= Lan_im; 
tk = Tnlit; goto lx_root_tk; // csw
} else  { cn++; 
tk = Tnlit; goto lx_root_tk; // csw
}  

//   c 2  t 2  u 0
lx_flitxs:
  
  c = sp[n++];
      if (c == '+'  ) { goto lx_flitx0; // csw
}  else if (c == '-'  ) { goto lx_flitx0; // csw
}  else if ( (t = ctab[c]) == N0) { goto lx_flitx0; // csw
}  else if (t == NM   ) { goto lx_flitx; // csw
} else  { goto lxer_flitxs_4_1; // csw
}  

//   c 0  t 3  u 0
lx_flitx0:
  
  c = sp[n];
      if ( (t = ctab[c]) == N0) { n++; goto lx_flitx0; // csw
}  else if (t == UU   ) { n++; goto lx_flitx0; // csw
}  else if (t == NM   ) { n++; exdig=1; 
goto lx_flitx; // csw
} else  { ctls[cn++] = Lan_a; 
tk = Tnlit; goto lx_root_tk; // csw
}  

//   c 1  t 1  u 1
lx_flitx:
  
  c = sp[n];
      if ( (utab[c] & NU) ) { n++; 
  if (exdig++ > 5) lxerror(l,0,"flitx","nu",c,"excess exponent digits"); 

goto lx_flitx; // csw
}  else if (c == '_'  ) { n++; goto lx_flitx; // csw
}  else if (c == 'j'  ) { n++; exdig=min(exdig,3); ctls[cn++] = exdig << 4; 
tk = Tnlit; goto lx_root_tk; // csw
} else  { 
  exdig=min(exdig,3); ctls[cn++] = Lan_a | (exdig << 4); 

tk = Tnlit; goto lx_root_tk; // csw
}  

//   c 0  t 1  u 1
lx_nlite0:
  
  c = sp[n++];
      if (ctab[c] == PM) { goto lx_nlite; // csw
}  else if ( (utab[c] & NU) ) { goto lx_nlite; // csw
} else  { goto lxer_nlite0_2_1; // csw
}  

//   c 0  t 0  u 1
lx_nlite:
  
  c = sp[n];
      if ( (utab[c] & NU) ) { n++; goto lx_nlite; // csw
} else  { ctls[cn++] = 0; 
tk = Tnlit; goto lx_root_tk; // csw
}  

//   c 1  t 2  u 0
lx_ilitb0:
  
  c = sp[n++];
      if ( (t = ctab[c]) == N0) { goto lx_ilitb0; // csw
}  else if (c == '1'  ) { i8 = 1; 
goto lx_ilitb; // csw
}  else if (t == UU   ) { goto lx_ilitb0; // csw
} else  { goto lxer_ilitb0_3_1; // csw
}  

//   c 1  t 2  u 0
lx_ilitb:
  
  c = sp[n];
      if ( (t = ctab[c]) == N0) { n++; i8 <<= 1; 
goto lx_ilitb; // csw
}  else if (c == '1'  ) { n++; i8 = i8 << 1 | 1; 
goto lx_ilitb; // csw
}  else if (t == UU   ) { n++; goto lx_ilitb; // csw
} else  { 
  // ilit
if (i8 < 64) ctls[cn++] = (ub1)i8;
  else if (i8 <= hi16) { ctls[cn++] = (ub1)i8; }
  else { bits[bn++] = i8; }
  
 

tk = Tnlit; goto lx_root_tk; // csw
}  

//   c 0  t 3  u 1
lx_ilitx0:
  
  c = sp[n++];
      if ( (t = ctab[c]) == N0) { goto lx_ilitx0; // csw
}  else if (t == NM   ) { i8 = c - '0'; 
goto lx_ilitx; // csw
}  else if ( (utab[c] & HX) ) { i8 = (c | 0x20) - 'a'; 
goto lx_ilitx; // csw
}  else if (t == UU   ) { goto lx_ilitx0; // csw
} else  { goto lxer_ilitx0_4_1; // csw
}  

//   c 0  t 3  u 1
lx_ilitx:
  
  c = sp[n];
      if ( (t = ctab[c]) == N0) { n++; i8 <<= 4; 
goto lx_ilitx; // csw
}  else if (t == NM   ) { n++; i8 = i8 <<4 | (c - '0'); 
goto lx_ilitx; // csw
}  else if ( (utab[c] & HX) ) { n++; i8 = i8 <<4 | ((c | 0x20) - 'a'); 
goto lx_ilitx; // csw
}  else if (t == UU   ) { n++; goto lx_ilitx; // csw
} else  { 
  // ilit
if (i8 < 64) ctls[cn++] = (ub1)i8;
  else if (i8 <= hi16) { ctls[cn++] = (ub1)i8; }
  else { bits[bn++] = i8; }
  
 

tk = Tnlit; goto lx_root_tk; // csw
}  

//   c 2  t 0  u 0
lx_slit0:
  
  c = sp[n];
      if (c == Q    ) { n++; len = 0;  
goto lx_slitcat0; // csw
}  else if (c == '\\' ) { goto lx_slit; // csw
} else  { n++; N=n; slitx = slitpos; slitpool[slitx++] = c; 
goto lx_slit; // csw
}  

// string literal  c 3  t 0  u 0
lx_slit:
  
  c = sp[n++];
      if (c == Q    ) { len = n - N; 
goto lx_slitcat0; // csw
}  else if (c == '\\'  &&  sp[n] == Q) { n++; slitpool[slitx++] = Q; 
goto lx_slit; // csw
}  else if (c == '\\' ) { goto lx_slitesc; // csw
} else  { slitpool[slitx++] = c; 
goto lx_slit; // csw
}  

//   c 0  t 0  u 0
lx_slitesc:
  
       { 
  // doesc
c = sp[n++];
  if (c < 0x80) x1 = esctab[c];
  else x1 = 0;
  switch(x1) {
  case Esc_nl: lntab[l++] = n; nlcol=n; break;
  case Esc_o:
    x1 = c - '0';
    c = sp[n];
    if (c >= '0' && c <= '7') { n++; x1 = (x1 << 3) + (c - '0'); } else { slitpool[slitx++] = x1; break; }
    c = sp[n];
    if (c >= '0' && c <= '7') { n++; x1 = (x1 << 3) + (c - '0'); }
    slitpool[slitx++] = x1;
    break;
  case Esc_x: n=doescx(sp,n,slitpool,&slitx,slitctl & Slitctl_b);
              break;
  case Esc_u:
  case Esc_U: n=doescu(sp,n,slitpool,&slitx,x1); break;
  case Esc_N: n=doescn(sp,n,slitpool,&slitx);    break;
  case Esc_inv:
    // sinfo(n,"'\\%s'",chprint(c));
    // lxwarn(l,0,787,c,"unrecognised escape sequence");
    slitpool[slitx] = '\\';
    slitpool[slitx+1] = c;
    slitx += 2;
    break;
  default:    slitpool[slitx++] = x1;
  }
  
 

goto lx_slit; // csw
}  

//   c 1  t 1  u 0
lx_slitcat0:
  
  c = sp[n];
      if (c == ' '  ) { n++; goto lx_slitcat0; // csw
}  else if (ctab[c] == QQ) { n++; goto lx_slit0; // csw
} else  { 
  // slit
// vrb(" add slit pos %u len %2u typ %u.%u '%s'",dn1,len,sla,R0,chprintn(sp+N-1,min(len,512),nil,sla));
  len = slitx - slitpos;
  switch(len) {
  case 1: atr = slitpool[slitpos]; ctl |= 1; break;
  case 2: atr = (slitpool[slitpos] << 8) | slitpool[slitpos]; ctl |= 2; break;
  default: id = slitgetadd(n,slitpool,slitx,ctl);
           if (id <= hi16) { atr = id; ctl |= Las_v2; }
           else bits[bn++] = id;
           ctl |= 3;
  }
  R0=ctl=0;
  atrs[an++] = atr;
  ctls[cn++] = ctl;
  
 

tk = Tslit; goto lx_root_tk; // csw
}  
#undef UU
#undef AF
#undef N0
#undef NM
#undef HT
#undef VT
#undef CR
#undef NL
#undef HS
#undef QQ
#undef CO
#undef RO
#undef SO
#undef CC
#undef RC
#undef SC
#undef AO
#undef AC
#undef CL
#undef SM
#undef CA
#undef DT
#undef EQ
#undef PM
#undef O1
#undef O2
#undef EOF
#undef AN
#undef NU
#undef HX
#undef WS
lxer_root_28_1: lxerror(l,n-nlcol,"root",nil,c,"unexpected char");
lxer_flitxs_4_1: lxerror(l,n-nlcol,"flitxs",nil,c,"unexpected char");
lxer_nlite0_2_1: lxerror(l,n-nlcol,"nlite0",nil,c,"unexpected char");
lxer_ilitb0_3_1: lxerror(l,n-nlcol,"ilitb0",nil,c,"unexpected char");
lxer_ilitx0_4_1: lxerror(l,n-nlcol,"ilitx0",nil,c,"unexpected char");

lx_eof:

