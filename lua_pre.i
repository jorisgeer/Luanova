/* lua_pre.i - lexer core, pass 1

   generated by genlex 0.1.0-alpha  3 Oct 2022  5:12

   from pre.lex 0.1.0  3 Oct 2022  4:46 lua
   options: code yes  tokens yes
 */
#define AF 0  //  ' ABCDEFGHIJKLMNOPQSTUVWXYZ_abcdefghijklmnopqstuvwxyz'
#define NM 1  //  ' 123456789'
#define N0 2  //  ' 0'
#define HT 3  //  ' \t '
#define VT 4  //  ' \f '
#define CR 5  //  ' \r '
#define NL 6  //  ' \n '
#define HS 7  //  ' # '
#define SQ 8  //  ' ' '
#define DQ 9  //  ' " '
#define RR 10 //  ' r'
#define BO 11 //  ' ( [ { '
#define BC 12 //  ' ) ] } '
#define DT 13 //  ' . '
#define OP 14 //  ' ! % & * + - / < > @ ^ | ~ '
#define PC 15 //  ' , : ; = ? '
#define EOF 16 //  ' \0 '
#define AN 1  // + ' 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'
#define NX 2  // + ' . 0123456789_'
#define XN 4  // + ' 0123456789ABCDEF_abcdef'
#define WS 0  // - '   '


  void *compgo1_root[18] = {
  &&lx_id,	// t=af af
  &&lx_nm,	// t=nm nm
  &&lx_n0,	// t=n0 n0
  &&lx_root,	// t=ht ht
  &&lx_root,	// t=vt vt
  &&lx_root,	// t=cr cr
  &&lx_root_Cnl_0,	// t=nl nl
  &&lx_cmt,	// t=hs hs
  &&lx_slits0,	// t=sq sq
  &&lx_slitd0,	// t=dq dq
  &&lx_xid,	// t=rr rr
  &&lx_root_Cbo_0,	// t=bo bo
  &&lx_root_Cbc_0,	// t=bc bc
  &&lx_dot,	// t=dt dt
  &&lx_root_Cop_0,	// t=op op
  &&lx_root_Cpc_0,	// t=pc pc
  &&lx_root_CEOF_0,	// t=EOF EOF
  
  &&lxer_root_18_1};	// ln 162


// N  c 1  t 17  u 0
lx_root:
  
  while (sp[n] == ' ') n++; // 32 
  N = n; c = sp[n++];

   t = ctab[c];  goto *compgo1_root[t];
  
lx_root_Cnl_0: // from root.nl set 6 ctl 1
l++; nlcol = n;   goto lx_root;

lx_root_Cbo_0: // from root.bo set 11 ctl 1
// dobo
if (bolvl >= Depth) lxerror(l,0,"root",nil,bolvl,"exceeding nesting depth");
  bolvls[bolvl] = l;
  bolvlc[bolvl++] = c;
  tkcnt++;
  
 
  goto lx_root;

lx_root_Cbc_0: // from root.bc set 12 ctl 1
// dobc
if (bolvl == 0) {
    lxinfo(bclvls[0],0,"final close here");
    lxerror(l,0,"root",nil,c,"unbalanced");
  }
  bolvl--;
  if (bolvlc[bolvl] != c) {
    lxinfo(bolvls[bolvl],0,"opened here");
    lxerror(l,0,"root",nil,c,"unmatched");
  }
  bclvls[bolvl] = l;
  tkcnt++;
  
 
  goto lx_root;

lx_root_Cop_0: // from root.op set 14 ctl 1
tacnt++;   goto lx_root;

lx_root_Cpc_0: // from root.pc set 15 ctl 1
tkcnt++;   goto lx_root;

lx_root_CEOF_0: // from root.EOF set 16 ctl 1
if (bolvl) { lxinfo(l,0,"opened here"); lxerror(l,0,"root","EOF",bolvlc[0],"unmatched"); } 
  goto lx_eof;


//   c 2  t 0  u 0
lx_cmt:
  
  c = sp[n++];
      if (c == '\n' ) { cmtcnt++; 
goto lx_root; // csw
}  else if (c == 0    ) { 
  if (bolvl) { lxinfo(l,0,"opened here"); lxerror(l,0,"cmt",".EOF",bolvlc[0],"unmatched"); } 

goto lx_eof; // csw
} else  { goto lx_cmt; // csw
}  

//   c 1  t 1  u 0
lx_dot:
  
  c = sp[n];
      if (ctab[c] == NM) { n++; goto lx_nm; // csw
}  else if ((c | 0x20) == 'e') { n++; goto lx_fxp0; // csw
} else  { tkcnt++; 
goto lx_root; // csw
}  

//   c 0  t 0  u 1
lx_id:
  
  c = sp[n];
      if ( (utab[c] & AN) ) { n++; goto lx_id1; // csw
} else  { tacnt++;  
goto lx_root; // csw
}  

//   c 0  t 0  u 1
lx_id1:
  
  c = sp[n];
      if ( (utab[c] & AN) ) { n++; goto lx_id2; // csw
} else  { tacnt++;  
goto lx_root; // csw
}  

//   c 0  t 0  u 1
lx_id2:
  
  c = sp[n];
      if ( (utab[c] & AN) ) { n++; goto lx_id2; // csw
} else  { tacnt++; 
goto lx_root; // csw
}  

//   c 1  t 1  u 0
lx_xid:
  
  c = sp[n];
      if (ctab[c] == AF) { n++; goto lx_xid; // csw
}  else if (c == ' '  ) { n++; 
  // chkimp
len = n - N;
  if (len == 8 && memcmp(sp+N,"requires",8) == 0) {
    isreq = 1;
  } else { isreq = 0; tacnt++; }
  
 

goto lx_root; // csw
} else  { 
  isreq=0; tacnt++;
// id
len = n - N;
  if (len > 2) {
    hc = hashstr(sp + N,len,0);
    idcnt++;
    exp_first0(hc,idsketchs);
  }
  
 

goto lx_root; // csw
}  

//   c 1  t 0  u 1
lx_n0:
  
  c = sp[n];
      if ((c | 0x20) == 'x') { n++; goto lx_xnm; // csw
}  else if ( (utab[c] & NX) ) { n++; goto lx_nm1; // csw
} else  { nlit1cnt++; 
goto lx_root; // csw
}  

//   c 1  t 0  u 1
lx_nm1:
  
  c = sp[n];
      if ( (utab[c] & NX) ) { n++; goto lx_nm; // csw
}  else if ((c | 0x20) == 'e') { n++; goto lx_fxp0; // csw
} else  { nlit1cnt++; 
goto lx_root; // csw
}  

//   c 1  t 0  u 1
lx_nm:
  
  c = sp[n];
      if ( (utab[c] & NX) ) { n++; goto lx_nm; // csw
}  else if ((c | 0x20) == 'e') { n++; goto lx_fxp0; // csw
} else  { nlitcnt++; if (n - N < 4) acnt++; else bitcnt++; 
goto lx_root; // csw
}  

// 0x  c 0  t 0  u 1
lx_xnm:
  
  c = sp[n];
      if ( (utab[c] & XN) ) { n++; goto lx_xnm; // csw
} else  { nlitcnt++; if (n - N < 4) acnt++; else bitcnt++; 
goto lx_root; // csw
}  

//   c 1  t 1  u 0
lx_fxp0:
  
  c = sp[n];
      if (c == 'p'   &&  sp[n+1] == 'm') { n += 2; goto lx_fxp; // csw
}  else if (ctab[c] == NM) { n++; goto lx_fxp; // csw
} else  { nlitcnt++; 
goto lx_root; // csw
}  

//   c 0  t 1  u 0
lx_fxp:
  
  c = sp[n];
      if (ctab[c] == NM) { n++; goto lx_fxp; // csw
} else  { nlitcnt++; 
goto lx_root; // csw
}  

//   c 4  t 0  u 0
lx_slits0:
  
  c = sp[n];
      if (c == '\'' ) { n++; tacnt++;  
goto lx_root; // csw
}  else if (c == '\n' ) { goto lx_slits; // csw
}  else if (c == 0    ) { goto lx_slits; // csw
}  else if (c == '\\' ) { goto lx_slits; // csw
} else  { n++; N=n; L=l; Nlcol=nlcol; 
goto lx_slits; // csw
}  

//   c 4  t 0  u 0
lx_slitd0:
  
  c = sp[n];
      if (c == '"'  ) { n++; tacnt++; 
goto lx_root; // csw
}  else if (c == '\n' ) { goto lx_slitd; // csw
}  else if (c == 0    ) { goto lx_slitd; // csw
}  else if (c == '\\' ) { goto lx_slitd; // csw
} else  { n++; N=n; L=l; Nlcol=nlcol; 
goto lx_slitd; // csw
}  

// string literal  c 6  t 0  u 0
lx_slits:
  
  c = sp[n++];
      if (c == '\'' ) { goto lx_slit9; // csw
}  else if (c == '\\'  &&  ctab[sp[n]] == SQ) { n++; goto lx_slits; // csw
}  else if (c == '\\'  &&  ctab[sp[n]] == NL) { n++; 
  lxerror(l,n-nlcol,"slits","\nl",hi16,"escaped newline in slit");  

 // csw
}  else if (c == '\\' ) { goto lx_slits; // csw
}  else if (c == 0    ) { 
  lxinfo(L,N-Nlcol,"slit started here"); lxerror(l,n-nlcol,"slits",".EOF",hi16,"missing end quote (')");  

 // csw
}  else if (c == '\n' ) { 
  lxerror(l,n-nlcol,"slits",".nl",hi16,"newline in slit");  

 // csw
} else  { goto lx_slits; // csw
}  

// string literal  c 6  t 0  u 0
lx_slitd:
  
  c = sp[n++];
      if (c == '"'  ) { goto lx_slit9; // csw
}  else if (c == '\\'  &&  ctab[sp[n]] == DQ) { n++; goto lx_slitd; // csw
}  else if (c == '\\'  &&  ctab[sp[n]] == NL) { n++; 
  lxerror(l,n-nlcol,"slitd","\nl",hi16,"escaped newline in slit");  

 // csw
}  else if (c == '\\' ) { goto lx_slitd; // csw
}  else if (c == 0    ) { 
  lxinfo(L,N-Nlcol,"slit started here"); lxerror(l,n-nlcol,"slitd",".EOF",hi16,"missing end quote (\")");  

 // csw
}  else if (c == '\n' ) { 
  lxerror(l,n-nlcol,"slitd",".nl",hi16,"newline in slit");  

 // csw
} else  { goto lx_slitd; // csw
}  

//   c 0  t 0  u 0
lx_slit9:
  
       { 
  // doslit
len = n - N;
  if (isreq) {
    isreq=0;
    addmod(spos,N,len,1);
    modcnt++;
  }
  switch (len) {
  case 1: slit1cnt++; break;
  case 2: slit2cnt++; break;
  default: slitncnt++;
  }
  slitpos += len;
  
 

goto lx_root; // csw
}  
#undef AF
#undef NM
#undef N0
#undef HT
#undef VT
#undef CR
#undef NL
#undef HS
#undef SQ
#undef DQ
#undef RR
#undef BO
#undef BC
#undef DT
#undef OP
#undef PC
#undef EOF
#undef AN
#undef NX
#undef XN
#undef WS
lxer_root_18_1: lxerror(l,n-nlcol,"root",nil,c,"unexpected char");

lx_eof:

