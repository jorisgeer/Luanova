/* pre.c - preprocess

   This file is part of Luanova, a fresh implementation of Lua.

   Copyright Â© 2022 Joris van der Geer.

   Luanova is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Luanova is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU Affero General Public License
   along with this program, typically in the file License.txt
   If not, see http://www.gnu.org/licenses.
 */

/* Source files are preprocessed into a linear file expanding all import/require/load/include.
   Output contains embedded file+line directives
 */

#include <stdarg.h>
#include <string.h>
#include <stdlib.h>

#include "base.h"
#include "chr.h"

#include "os.h"

#include "mem.h"

#include "fmt.h"

#include "hash.h"

static ub4 msgfile = Shsrc_pre;
#include "msg.h"

#include "util.h"

#include "pre.h"

#include "predef.h" // generated by genlex

#define Depth 256

// max token stream len
#define Tokencnt (1U << 28)

static bool verbose;

static cchar *srcnam;

static void lxdiag(enum Msglvl lvl,ub4 ln,ub4 col,cchar *state,cchar *pat,ub4 c,cchar *msg)
{
  char buf[1024];
  ub4 pos=0,blen = 1024;

  if (verbose) {
    if (state && *state) pos = mysnprintf(buf,0,blen,"%s state %s",specnam,state);
    if (pat && *pat) pos = mysnprintf(buf,0,blen,"pattern '%s'",pat);
  }
  if (c != hi16) pos += mysnprintf(buf,pos,blen,"at char '%s' : ",chprint(c));
  buf[pos] = 0;

  if (msg == nil) msg = "unexpected";
  vpmsg(FLN,lvl,srcnam,ln+1,col+1,buf,nil,msg);
}

static Noret void lxerror(ub4 ln,ub4 col,cchar *state,cchar *pat,ub4 c,cchar *msg)
{
  lxdiag(Fatal,ln,col,state,pat,c,msg);
  doexit(1);
}

static void lxinfo(ub4 ln,ub4 col,cchar *msg)
{
  vpmsg(FLN,Info,srcnam,ln+1,col+1,"",nil,msg);
}

static ub1 inolut[256];

static bool samefile(ub4 cnt,struct filinf *files,struct osstat *osp)
{
  ub8 ino = osp->ino;
  ub8 dev = osp->dev;

  ub4 i = (ino & hi32) ^ (ino >> 32);
  ub4 f;

  ub1 x = inolut[i & 0xff]
      | inolut[(i >> 8) & 0xff]
      | inolut[(i >> 16) & 0xff]
      | inolut[i >> 24];
  if (x != 0xf) return 0;

  ub4 d = (dev & hi32) ^ (dev >> 32);

  x = inolut[d & 0xff]
      | inolut[(d >> 8) & 0xff]
      | inolut[(d >> 16) & 0xff]
      | inolut[d >> 24];

  if (x != 0xf0) return 0;

  for (f = 0; f < cnt; f++) {
    if (files[f].ino == ino && files[f].dev == dev) return 1;
  }
  inolut[i & 0xff] |= 1;
  inolut[(i >> 8) & 0xff] |= 2;
  inolut[(i >> 16) & 0xff] |= 4;
  inolut[i >> 24] |= 8;

  inolut[d & 0xff] |= 16;
  inolut[(d >> 8) & 0xff] |= 32;
  inolut[(d >> 16) & 0xff] |= 64;
  inolut[d >> 24] |= 128;

  return 0;
}

static int tryopen(cchar *dir,cchar *name,bool need)
{
  char path[Pathname];
  cchar *p;
  int fd;

  if (dir == nil || *dir == 0 || (dir[0] == '.' && dir[1] == '/') ) p = name;
  else {
    mysnprintf(path,0,Pathname,"%s/%s",dir,name);
    p = path;
  }

  if (osopenseq(p,&fd) && need) error("cannot open %s",p);
  return fd;
}

static ub4 wrfid(ub1 *p,ub4 n,ub4 id)
{
  p[n] = id & 0xff;
  p[n+1] = (id >> 8) & 0xff;
  p[n+3] = (id >> 16) & 0xff;
  return n+3;
}

static ub4 idsketch;
#define R(x) ~(x) & ((x)+1)

// cs.princeton.edu/~rs/talks/AC11-Cardinality.pdf  philippe flajolet / martin '85
static void exp_first0(ub4 x,ub4 *sketchs)
{
  ub4 i,s = ((x >> 16) ^ x) * 0x45d9f3b; // int32 hash after thomas muller

  s = ((s >> 16) ^ s) * 0x45d9f3b;
  s = (s >> 16) ^ s;
  i = s & 0xf;

  ub4 e = R(x);

  sketchs[i] |= e;
  idsketch |= e;
}

static ub4 exp_est(ub4 *sketchs)
{
  ub4 x,sum=0,i;

  for (i=0; i < 16; i++) {
    x = R(sketchs[i]);
    vrbo("%2u %08x",i,x);
    sum += x;
  }
//  sum >>= 4;
  x = R(idsketch);
  info("  sketch %x vs %x",sum,x);

  return sum + (sum >> 1);
}

#define Modstk 256

struct mod {
  ub4 nam;
  ub2 len;
  ub1 typ;
};

static struct mod modstk[Modstk];
static ub2 modsp;

static void addmod(ub4 spos,ub4 N,ub4 len,ub1 typ)
{
  struct mod *m = modstk + modsp;

  m->nam = spos + N;
  m->len = len;
  m->typ = typ;
  modsp++;
}

static ub2 Pad = 6; // 2 eof 1 nl 3 fid

int prelex(cchar *srcpath,enum Inctyp inc,struct prelex *presp,ub8 T0)
{
  int rv = 1;
  ub4 t0 = (ub4)(T0 / 1000);
  ub4 dirsep = 0;
  int fd;
  cchar *parpath = nil;
  cchar *path;
  ub2 plen;

  struct filinf *fip=nil;
  ub4 filcnt = 0;
  ub4 filid = 0,parfid;

  struct mod *modp;
  ub4 modid=0;
  ub4 modcnt=0;
  ub1 modtyp=0;

  struct expmem srcmem;
  struct expmem filmem;
  ub4 spos=0;

  // estimates
  ub4 tkcnt=0;
  ub4 tacnt=0;
  ub4 cmtcnt = 0;

  // idents
  ub4 euidcnt,idcnt = 0;

  ub4 idsketchs[16];

  // string lits
  ub4 slitncnt = 0;
  ub4 slit1cnt = 0;
  ub4 slit2cnt = 0;
  ub4 slitpos = 0;

  ub4 nlit1cnt = 0;
  ub4 nlitcnt = 0;

  ub4 acnt = 0;
  ub4 bitcnt = 0;

  // main char pointers
  ub4 N,n = 0,nn,ninc=0;

  // line control
  ub4 l=0,L=0;
  ub4 lncnt=0;
  ub4 nlcol=0,Nlcol=0;

  // match brackets
  ub2 bolvl = 0;
  ub1 bolvlc[Depth]; // char of opening brace [{(
  ub4 bolvls[Depth]; // lineno of opening brace
  ub4 bclvls[Depth]; // lineno of last closing brace

  ub1 c,t,*sp=nil,*src;
  ub2 incdir=0;
  ub4 slen=0;
  ub2 len;
  ub4 nr;
  ub4 hc;
  bool isreq = 0;

  struct osstat ino;
  char chkpath[Pathname];

  ub8 T1=0;

  memset(idsketchs,0,16 * 4);

  // source file store
  memset(&srcmem,0,sizeof(srcmem));
  srcmem.inc = (1U << 14);
  srcmem.ini = 1024;
  srcmem.elsiz = 1;
  srcmem.align = 1;
  srcmem.min = 1;

 // file IDs
  memset(&filmem,0,sizeof(filmem));
  srcmem.inc = (1U << 12);
  srcmem.ini = 1024;
  srcmem.elsiz = sizeof(struct filinf);
  srcmem.align = 4;
  srcmem.min = 1;

  memset(&inolut,0,sizeof(inolut));

  path = srcpath;
  plen = (ub4)strlen(path);

  while (path[n]) { if (path[n] == '/') dirsep = n; n++; }
  if (n == dirsep + 1) { errorfln(FLN,0,"lex: path '%s' is a directory",path); return 1; }

  timeit(&T1,nil);

 do {

  if (inc == Icmd) {
    fd = -1;
    slen = (ub4)strlen(path);
    srcnam = "(cmdline)";

  } else if (inc == Inone || dirsep == 0 || parpath == nil) {
    memcpy(chkpath,path,plen);
    chkpath[plen] = 0;
    fd = tryopen(nil,chkpath,1);
    if (fd == -1) return 1;

  } else if (inc == Iuser) { // search in dir of includer
    mysnprintf(chkpath,0,Pathname-2,"%.*s/%.*s",dirsep,parpath,plen,path);
    fd = tryopen(nil,chkpath,1);
    if (fd == -1) return 1;

  } else { // search in system dirs and -I

    do {
      mysnprintf(chkpath,0,Pathname-2,"%s/%.*s",presp->incdirs[incdir],plen,path);
      fd = tryopen(nil,chkpath,0);
    } while (fd == -1 && ++incdir < presp->incdircnt);
    if (fd == -1) { errorfln(FLN,0,"cannot open %.*s",plen,path); return 1; }
  }

  if (fd != -1) {
    if (osfdinfo(&ino,fd)) { osclose(fd); errorfln(FLN,0,"cannot get info for %s",chkpath); return 1; }
    if (ino.len >= hi32) { osclose(fd); errorfln(FLN,0,"%s length %lu` exceeds 4G",chkpath,ino.len); return 1; }

    if (samefile(filcnt,(struct filinf *)filmem.bas,&ino)) {
      info("skip duplicate %s ",chkpath);
      osclose(fd);
      goto endfil;
    }
    slen = (ub4)ino.len;
    srcnam = path;

    if (slen == 0) {
      info("%s is empty",chkpath);
      osclose(fd);
      goto endfil;
    }
  }

  spos = blkexp(&srcmem,slen+Pad,ub1);
  src = srcmem.bas + spos;

  if (fd != -1) {
    rv = osread(fd,(char *)src,slen,&nr);
    if (rv) {
      error("cannot read %s %m",chkpath);
      osclose(fd);
      return 1;
    }
    osclose(fd);
    if (nr != slen) { error("partial read %'uB of %'uB of %s",(ub4)nr,slen,chkpath); return 1; }
  } else {
    memcpy(src,path,slen);
  }

  if (src[0] == 0xef && slen > 2 && src[1] == 0xbb && src[2] == 0xbf) { // skip utf8 bom
    n = 3; slen -= 3;
    if (slen == 3) {
      info("%s is an empty utf-8 bom",chkpath);
      goto endfil;
    }
  } else n = 0;

  nn = n;
  if (slen > 3 && src[nn] == '#' && sp[nn+1] == '!') { // skip shebang
    while (nn < slen && sp[nn] != '\n') nn++;
    if (nn + 1 >= slen) {
      info("%s is an empty shebang",chkpath);
      goto endfil;
    }
    slen -= (nn - n);
  }

  filid = blkexp(&filmem,1,struct filinf);
  fip = blkptr(&filmem,filid,struct filinf);

  plen = strlen(chkpath);
  fip->ino = (ub4)ino.ino;
  fip->dev = (ub4)ino.dev;
  fip->modid = modid;
  fip->typ = modtyp;
  fip->nam = minalloc(plen+1,1,0,"pre nam");
  memcpy(fip->nam,chkpath,plen);
  sp = src + n + nn;
  fip->src = spos + n + nn;

  n = 0;
  l = 0;
  src[slen]   = 0; // eof
  src[slen+1] = 0;

#include "lua_pre.i"

  // come here at eof

  if (sp[slen-1] != '\n') sp[slen++] = '\n'; // for next pass

  sp[slen]   = 0; // eof

  fip->lncnt = l;
  fip->len = slen;

// ---------------
endfil:
// ---------------

  tkcnt += l;
  lncnt += l;

  if (tkcnt >= Tokencnt) serror(n,"token count %u` exceeds limit %u`",tkcnt,Tokencnt);

  if (modsp == 0) break;

  wrfid(sp,slen+1,filcnt);

  modp = modstk + modsp--;
  modid = spos + modp->nam;
  modtyp = modp->typ;

  path = (cchar *)srcmem.bas + modid;
  plen = modp->len;

 } while (1);

  spos = blkexp(&srcmem,Pad,ub1);
  src = srcmem.bas + spos;

  wrfid(src,0,hi32); // mark last file

  // end
  showcnt("3lncnt",lncnt);

  showcnt("3tkcnt",tkcnt);
  showcnt("3tacnt",tacnt);
  showcnt("3slitncnt",slitncnt);
  showcnt("3slit1cnt",slit1cnt);
  showcnt("3slit2cnt",slit2cnt);
  showcnt("3nlitcnt",nlitcnt);
  showcnt("3bitcnt",bitcnt);
  showcnt("3filcnt",filcnt);

  if (idcnt > 1024) {
    euidcnt = exp_est(idsketchs);
    showcnt("4est unique ident",euidcnt);
  }

  ub2 hidepth = (ub2)((ub1 *)memchr(bolvlc,0,Depth) - bolvlc);
  info("max depth %u",hidepth);
//  presp->hidepth = hidepth;

  presp->lncnt = lncnt;

  presp->tkcnt = tkcnt + tacnt;
  presp->tacnt = tacnt;
  presp->cmtcnt = cmtcnt;

  presp->slitncnt = slitncnt;
  presp->slit1cnt = slit1cnt;
  presp->slit2cnt = slit2cnt;
  presp->slittop = slitpos;

  presp->nlitcnt = nlitcnt;

  if (slitncnt > 65536) bitcnt += (slitncnt - 65536);
  presp->bitcnt = bitcnt;

  presp->files = (struct filinf *)filmem.bas;
  presp->filcnt = filcnt;
  presp->modcnt = modcnt;

  if (globs.rununtil == 1) { info("until file %u",gettime_msec()-t0); return 0; }

  if (rv || presp->tkcnt == 0) return rv;

  timeit2(&T0,slen,"preprocessed ` in");

  return 0;
}

void inipre(void)
{
  genmsgfln(0,Info,"%s\n",lexinfo);

  verbose = globs.msglvl >= Vrb;

  lastcnt
}
